# Equation Index: Book Equations → Code Mapping
#
# This file maps equations from "Principles of Indoor Positioning and Indoor Navigation"
# to their implementations in the codebase.
#
# Format:
#   - eq: "Eq. (C.NN)"          # Equation identifier from book
#     chapter: N                 # Chapter number
#     description: "..."         # Brief description
#     files:                     # List of implementing files
#       - path: "..."            # File path
#         object: "..."          # Function/class name
#     tests:                     # List of test files (optional)
#       - "..."
#     notebooks:                 # List of notebooks (optional)
#       - "..."
#     notes: "..."               # Additional notes (optional)

# ==============================================================================
# Chapter 2: Coordinate Systems and Attitude Representations
# ==============================================================================

- eq: "Eq. (2.1)"
  chapter: 2
  description: "LLH to ECEF coordinate transformation"
  files:
    - path: "core/coords/transforms.py"
      object: "llh_to_ecef"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_transforms.py::TestLLHtoECEF"
    - "tests/core/coords/test_transforms.py::TestRoundTripLLHECEF"
  notes: "Uses WGS84 ellipsoid parameters. Closed-form solution."

- eq: "Eq. (2.2)"
  chapter: 2
  description: "ECEF to LLH coordinate transformation (iterative)"
  files:
    - path: "core/coords/transforms.py"
      object: "ecef_to_llh"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_transforms.py::TestECEFtoLLH"
    - "tests/core/coords/test_transforms.py::TestRoundTripLLHECEF"
  notes: "Iterative algorithm with configurable tolerance (default 1e-12 m). Handles poles as special case."

- eq: "Eq. (2.3)"
  chapter: 2
  description: "ECEF to ENU (East-North-Up) local frame transformation"
  files:
    - path: "core/coords/transforms.py"
      object: "ecef_to_enu"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_transforms.py::TestECEFtoENU"
    - "tests/core/coords/test_transforms.py::TestRoundTripECEFENU"
  notes: "Rotation matrix from ECEF to local tangent plane at reference point."

- eq: "Eq. (2.4)"
  chapter: 2
  description: "ENU to ECEF coordinate transformation"
  files:
    - path: "core/coords/transforms.py"
      object: "enu_to_ecef"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_transforms.py::TestENUtoECEF"
    - "tests/core/coords/test_transforms.py::TestRoundTripECEFENU"
  notes: "Inverse of ECEF to ENU transformation."

- eq: "Eq. (2.5)"
  chapter: 2
  description: "Euler angles to rotation matrix (ZYX convention)"
  files:
    - path: "core/coords/rotations.py"
      object: "euler_to_rotation_matrix"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestEulerToRotationMatrix"
    - "tests/core/coords/test_rotations.py::TestRoundTripEulerRotationMatrix"
  notes: "ZYX (yaw-pitch-roll) Euler angle convention. Returns proper orthogonal matrix in SO(3)."

- eq: "Eq. (2.6)"
  chapter: 2
  description: "Rotation matrix to Euler angles"
  files:
    - path: "core/coords/rotations.py"
      object: "rotation_matrix_to_euler"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestRotationMatrixToEuler"
    - "tests/core/coords/test_rotations.py::TestRoundTripEulerRotationMatrix"
  notes: "Handles gimbal lock at pitch = ±90° by setting roll = 0 by convention."

- eq: "Eq. (2.7)"
  chapter: 2
  description: "Euler angles to quaternion"
  files:
    - path: "core/coords/rotations.py"
      object: "euler_to_quat"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestEulerToQuaternion"
    - "tests/core/coords/test_rotations.py::TestRoundTripEulerQuaternion"
  notes: "Returns unit quaternion [qw, qx, qy, qz] with scalar-first convention."

- eq: "Eq. (2.8)"
  chapter: 2
  description: "Quaternion to Euler angles"
  files:
    - path: "core/coords/rotations.py"
      object: "quat_to_euler"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestQuaternionToEuler"
    - "tests/core/coords/test_rotations.py::TestRoundTripEulerQuaternion"
  notes: "Expects unit quaternion [qw, qx, qy, qz]. Clamps arcsin argument to [-1, 1]."

- eq: "Eq. (2.9)"
  chapter: 2
  description: "Quaternion to rotation matrix"
  files:
    - path: "core/coords/rotations.py"
      object: "quat_to_rotation_matrix"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestQuaternionToRotationMatrix"
    - "tests/core/coords/test_rotations.py::TestRoundTripQuaternionRotationMatrix"
  notes: "Returns proper orthogonal matrix. Assumes input quaternion is normalized."

- eq: "Eq. (2.10)"
  chapter: 2
  description: "Rotation matrix to quaternion (Shepperd's method)"
  files:
    - path: "core/coords/rotations.py"
      object: "rotation_matrix_to_quat"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestRotationMatrixToQuaternion"
    - "tests/core/coords/test_rotations.py::TestRoundTripQuaternionRotationMatrix"
  notes: "Uses Shepperd's method for numerical stability. Chooses largest diagonal element. Normalizes output."

# ==============================================================================
# Chapter 3: Estimation and Filtering (Placeholder)
# ==============================================================================
# To be added when Chapter 3 estimators are implemented

# ==============================================================================
# Chapter 4: RF Point Positioning by Radio Signals
# ==============================================================================

# TOA (Time of Arrival) Ranging
- eq: "Eq. (4.1)"
  chapter: 4
  description: "Basic TOA range measurement"
  files:
    - path: "core/rf/measurement_models.py"
      object: "toa_range"
    - path: "ch4_rf_point_positioning/example_toa_positioning.py"
      object: "demo_toa_basic"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestTOA::test_toa_range_2d"
    - "tests/core/rf/test_measurement_models.py::TestTOA::test_toa_range_3d"
  notes: "Distance = c * time_of_flight, where c is speed of light"

- eq: "Eq. (4.6)"
  chapter: 4
  description: "Two-way TOA (RTT) range measurement"
  files:
    - path: "core/rf/measurement_models.py"
      object: "two_way_toa_range"
    - path: "ch4_rf_point_positioning/example_toa_positioning.py"
      object: "demo_two_way_toa"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestTOA::test_two_way_toa"
  notes: "Round-trip time distance with optional processing delay correction"

# RSS (Received Signal Strength) Ranging
- eq: "Eq. (4.11)"
  chapter: 4
  description: "Path-loss model for RSS measurements"
  files:
    - path: "core/rf/measurement_models.py"
      object: "rss_pathloss"
    - path: "ch4_rf_point_positioning/example_comparison.py"
      object: "rss_positioning_test"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestRSS::test_rss_pathloss"
  notes: "RSS = Ptx - 10*n*log10(d/d0) - X_sigma, where n is path-loss exponent"

- eq: "Eq. (4.13)"
  chapter: 4
  description: "RSS to distance conversion"
  files:
    - path: "core/rf/measurement_models.py"
      object: "rss_to_distance"
    - path: "ch4_rf_point_positioning/example_comparison.py"
      object: "rss_positioning_test"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestRSS::test_rss_to_distance"
  notes: "Inverts path-loss model to estimate distance from RSS"

# TOA Positioning Algorithms
- eq: "Eqs. (4.14)-(4.23)"
  chapter: 4
  description: "Nonlinear TOA I-WLS (Iterative Weighted Least Squares)"
  files:
    - path: "core/rf/positioning.py"
      object: "TOAPositioner"
    - path: "ch4_rf_point_positioning/example_toa_positioning.py"
      object: "demo_toa_basic"
  tests:
    - "tests/core/rf/test_positioning.py::TestTOAPositioner"
  notes: "Iterative Gauss-Newton with weighting. Requires initial guess."

- eq: "Eqs. (4.24)-(4.26)"
  chapter: 4
  description: "TOA positioning with joint clock bias estimation"
  files:
    - path: "core/rf/positioning.py"
      object: "toa_solve_with_clock_bias"
    - path: "ch4_rf_point_positioning/example_toa_positioning.py"
      object: "demo_toa_with_clock_bias"
  tests:
    - "tests/core/rf/test_positioning.py::TestTOAPositioner::test_with_clock_bias"
  notes: "Extended state vector [x, y, clock_bias] for joint estimation"

# TDOA (Time Difference of Arrival)
- eq: "Eqs. (4.27)-(4.33)"
  chapter: 4
  description: "TDOA range difference measurements"
  files:
    - path: "core/rf/measurement_models.py"
      object: "tdoa_range_difference"
    - path: "core/rf/measurement_models.py"
      object: "tdoa_measurement_vector"
    - path: "ch4_rf_point_positioning/example_tdoa_positioning.py"
      object: "demo_tdoa_basic"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestTDOA"
  notes: "TDOA = range_i - range_ref eliminates receiver clock bias"

- eq: "Eqs. (4.34)-(4.42)"
  chapter: 4
  description: "TDOA I-WLS positioning algorithm"
  files:
    - path: "core/rf/positioning.py"
      object: "TDOAPositioner"
    - path: "ch4_rf_point_positioning/example_tdoa_positioning.py"
      object: "demo_tdoa_basic"
  tests:
    - "tests/core/rf/test_positioning.py::TestTDOAPositioner"
  notes: "Linearized TDOA with iterative weighted least squares"

- eq: "Eqs. (4.43)-(4.48)"
  chapter: 4
  description: "Fang's closed-form TDOA algorithm"
  files:
    - path: "core/rf/positioning.py"
      object: "tdoa_fang_solver"
    - path: "ch4_rf_point_positioning/example_tdoa_positioning.py"
      object: "demo_closed_form_algorithms"
  tests:
    - "tests/core/rf/test_positioning.py::TestTDOAPositioner::test_fang_solver"
  notes: "Closed-form hyperbolic TDOA solution (4 anchors minimum)"

- eq: "Eq. (4.58)"
  chapter: 4
  description: "Chan's two-step TDOA algorithm"
  files:
    - path: "core/rf/positioning.py"
      object: "tdoa_chan_solver"
    - path: "ch4_rf_point_positioning/example_tdoa_positioning.py"
      object: "demo_closed_form_algorithms"
  tests:
    - "tests/core/rf/test_positioning.py::TestTDOAPositioner::test_chan_solver"
  notes: "Two-step WLS refinement with covariance weighting"

# AOA (Angle of Arrival)
- eq: "Eqs. (4.63)-(4.67)"
  chapter: 4
  description: "AOA azimuth and elevation measurements"
  files:
    - path: "core/rf/measurement_models.py"
      object: "aoa_azimuth"
    - path: "core/rf/measurement_models.py"
      object: "aoa_elevation"
    - path: "core/rf/measurement_models.py"
      object: "aoa_measurement_vector"
    - path: "ch4_rf_point_positioning/example_aoa_positioning.py"
      object: "demo_aoa_basic"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestAOA"
  notes: "Azimuth = atan2(dy, dx), Elevation = atan2(dz, sqrt(dx^2+dy^2))"

- eq: "Eqs. (4.63)-(4.67)"
  chapter: 4
  description: "AOA I-WLS positioning algorithm"
  files:
    - path: "core/rf/positioning.py"
      object: "AOAPositioner"
    - path: "ch4_rf_point_positioning/example_aoa_positioning.py"
      object: "demo_aoa_basic"
  tests:
    - "tests/core/rf/test_positioning.py::TestAOAPositioner"
  notes: "Iterative weighted least squares for AOA positioning"

- eq: "Eq. (4.68)"
  chapter: 4
  description: "OVE (Optimal Velocity Estimator) for AOA"
  files:
    - path: "core/rf/positioning.py"
      object: "aoa_ove_solver"
    - path: "ch4_rf_point_positioning/example_aoa_positioning.py"
      object: "demo_closed_form_algorithms"
  tests:
    - "tests/core/rf/test_positioning.py::TestAOAPositioner::test_ove_solver"
  notes: "Closed-form AOA positioning algorithm (minimum 3 anchors)"

- eq: "Eq. (4.69)"
  chapter: 4
  description: "3D PLE (Position Line Estimation) for AOA"
  files:
    - path: "core/rf/positioning.py"
      object: "aoa_3dple_solver"
    - path: "ch4_rf_point_positioning/example_aoa_positioning.py"
      object: "demo_closed_form_algorithms"
  tests:
    - "tests/core/rf/test_positioning.py::TestAOAPositioner::test_3dple_solver"
  notes: "3D position line estimation for AOA (minimum 3 anchors)"

# DOP (Dilution of Precision)
- eq: "Section 4.5"
  chapter: 4
  description: "DOP computation (GDOP, PDOP, HDOP, VDOP)"
  files:
    - path: "core/rf/dop.py"
      object: "compute_dop"
    - path: "core/rf/dop.py"
      object: "compute_geometry_matrix"
    - path: "core/rf/dop.py"
      object: "compute_dop_map"
  tests:
    - "tests/core/rf/test_dop.py"
  notes: "Geometry matrix and DOP metrics for evaluating positioning quality"

# ==============================================================================
# Chapter 5: Fingerprinting (Placeholder)
# ==============================================================================
# To be added when Chapter 5 fingerprinting is implemented

# ==============================================================================
# Chapter 6: Dead Reckoning (Placeholder)
# ==============================================================================
# To be added when Chapter 6 PDR/sensors are implemented

# ==============================================================================
# Chapter 7: SLAM Technologies
# ==============================================================================

# ------------------------------------------------------------------------------
# Section 7.2.1: ICP (Iterative Closest Point) Scan Matching
# ------------------------------------------------------------------------------

- eq: "Eq. (7.10)"
  chapter: 7
  description: "ICP point-to-point matching objective (sum of squared distances)"
  files:
    - path: "core/slam/scan_matching.py"
      object: "compute_icp_residual"
    - path: "core/slam/scan_matching.py"
      object: "icp_point_to_point"
    - path: "ch7_slam/example_pose_graph_slam.py"
      object: "detect_loop_closures_icp"
  tests:
    - "tests/core/slam/test_scan_matching.py::TestComputeICPResidual"
    - "tests/core/slam/test_scan_matching.py::TestICPPointToPoint"
  notes: "Minimizes sum of squared Euclidean distances between corresponding points. Iterative algorithm with SVD-based rigid transform update."

- eq: "Eq. (7.11)"
  chapter: 7
  description: "ICP correspondence association with distance threshold"
  files:
    - path: "core/slam/scan_matching.py"
      object: "find_correspondences"
    - path: "core/slam/scan_matching.py"
      object: "icp_point_to_point"
  tests:
    - "tests/core/slam/test_scan_matching.py::TestFindCorrespondences"
    - "tests/core/slam/test_scan_matching.py::TestICPPointToPoint::test_max_correspondence_distance"
  notes: "Nearest-neighbor correspondence search with max_distance threshold (epsilon). Uses KD-tree for efficiency."

- eq: "SVD-based rigid alignment"
  chapter: 7
  description: "SVD (Singular Value Decomposition) for optimal rigid body transformation"
  files:
    - path: "core/slam/scan_matching.py"
      object: "align_svd"
  tests:
    - "tests/core/slam/test_scan_matching.py::TestAlignSVD"
  notes: "Computes optimal [x, y, yaw] transformation between matched point clouds using SVD (Procrustes problem). Core update step in ICP."

# ------------------------------------------------------------------------------
# Section 7.2.2: NDT (Normal Distributions Transform) Scan Matching
# ------------------------------------------------------------------------------

- eq: "Eqs. (7.12)-(7.13)"
  chapter: 7
  description: "NDT voxel statistics (mean and covariance per voxel)"
  files:
    - path: "core/slam/ndt.py"
      object: "build_ndt_map"
  tests:
    - "tests/core/slam/test_ndt.py::TestBuildNDTMap"
  notes: "Computes per-voxel Gaussian distribution (mean μ_k and covariance Σ_k) from point cloud. Requires minimum points per voxel."

- eq: "Eqs. (7.14)-(7.15)"
  chapter: 7
  description: "NDT negative log-likelihood (score function)"
  files:
    - path: "core/slam/ndt.py"
      object: "ndt_score"
  tests:
    - "tests/core/slam/test_ndt.py::TestNDTScore"
  notes: "Computes negative log-likelihood of transformed scan under NDT map Gaussian distributions. Lower score = better alignment."

- eq: "Eq. (7.16)"
  chapter: 7
  description: "NDT alignment via MLE optimization"
  files:
    - path: "core/slam/ndt.py"
      object: "ndt_align"
    - path: "core/slam/ndt.py"
      object: "ndt_gradient"
  tests:
    - "tests/core/slam/test_ndt.py::TestNDTAlign"
    - "tests/core/slam/test_ndt.py::TestNDTGradient"
  notes: "Optimizes pose to maximize likelihood (minimize negative log-likelihood). Uses gradient descent with numerical derivatives."

# ------------------------------------------------------------------------------
# Section 7.3: Pose Graph Optimization
# ------------------------------------------------------------------------------

- eq: "Section 7.3 (Pose Graph Framework)"
  chapter: 7
  description: "Pose graph optimization with odometry and loop closure factors"
  files:
    - path: "core/slam/factors.py"
      object: "create_pose_graph"
    - path: "core/slam/factors.py"
      object: "create_odometry_factor"
    - path: "core/slam/factors.py"
      object: "create_loop_closure_factor"
    - path: "core/slam/factors.py"
      object: "create_prior_factor"
    - path: "ch7_slam/example_pose_graph_slam.py"
      object: "main"
  tests:
    - "tests/core/slam/test_factors.py::TestPoseGraphCreation"
    - "tests/core/slam/test_factors.py::TestIntegration::test_full_slam_scenario"
  notes: "Complete pose graph SLAM: odometry factors connect consecutive poses, loop closure factors reduce drift, prior anchors first pose."

- eq: "Odometry Factor (SE(2) relative pose)"
  chapter: 7
  description: "Binary factor for odometry constraint between consecutive poses"
  files:
    - path: "core/slam/factors.py"
      object: "create_odometry_factor"
  tests:
    - "tests/core/slam/test_factors.py::TestOdometryFactor"
  notes: "Residual: r = (x_i^-1 ⊕ x_j) - z_ij, where z_ij is measured relative pose. Uses SE(2) operations."

- eq: "Loop Closure Factor"
  chapter: 7
  description: "Binary factor for loop closure constraint (from scan matching)"
  files:
    - path: "core/slam/factors.py"
      object: "create_loop_closure_factor"
  tests:
    - "tests/core/slam/test_factors.py::TestLoopClosureFactor"
  notes: "Structurally identical to odometry factor but connects non-consecutive poses. Information matrix from ICP/NDT covariance."

- eq: "Prior Factor"
  chapter: 7
  description: "Unary factor to anchor pose to known value"
  files:
    - path: "core/slam/factors.py"
      object: "create_prior_factor"
  tests:
    - "tests/core/slam/test_factors.py::TestPriorFactor"
  notes: "Residual: r = x - x_prior. Used to fix first pose (preventing gauge freedom) or incorporate GPS measurements."

- eq: "Landmark Factor (range-bearing)"
  chapter: 7
  description: "Binary factor connecting pose to landmark via range-bearing measurement"
  files:
    - path: "core/slam/factors.py"
      object: "create_landmark_factor"
  tests:
    - "tests/core/slam/test_factors.py::TestLandmarkFactor"
  notes: "For feature-based SLAM. Residual: r = h(x_i, l_k) - z_ik where h is range-bearing measurement model."

# ------------------------------------------------------------------------------
# Section 7.4: Visual SLAM - Camera Model
# ------------------------------------------------------------------------------

- eq: "Eq. (7.40)"
  chapter: 7
  description: "Pinhole camera projection (3D point to pixel coordinates)"
  files:
    - path: "core/slam/camera.py"
      object: "project_point"
  tests:
    - "tests/core/slam/test_camera.py::TestProjectPoint"
  notes: "Full projection: normalize to z=1, apply distortion, scale by intrinsics. u = fx*x_d + cx, v = fy*y_d + cy."

- eq: "Eqs. (7.43)-(7.46)"
  chapter: 7
  description: "Brown-Conrady lens distortion model (radial + tangential)"
  files:
    - path: "core/slam/camera.py"
      object: "distort_normalized"
    - path: "core/slam/camera.py"
      object: "undistort_normalized"
    - path: "core/slam/camera.py"
      object: "project_point"
  tests:
    - "tests/core/slam/test_camera.py::TestDistortNormalized"
    - "tests/core/slam/test_camera.py::TestUndistortNormalized"
  notes: "Radial distortion (k1, k2) and tangential distortion (p1, p2). Eq. 7.43: radial component. Eqs. 7.44-7.45: tangential. Eq. 7.46: combined."

- eq: "Inverse Projection"
  chapter: 7
  description: "Pixel to 3D ray (inverse of projection)"
  files:
    - path: "core/slam/camera.py"
      object: "unproject_pixel"
  tests:
    - "tests/core/slam/test_camera.py::TestUnprojectPixel"
  notes: "Inverts camera model: pixel → undistort → normalize → 3D ray. Optional depth parameter gives 3D point."

# ------------------------------------------------------------------------------
# Section 7.4: Visual SLAM - Bundle Adjustment
# ------------------------------------------------------------------------------

- eq: "Eqs. (7.68)-(7.70)"
  chapter: 7
  description: "Bundle adjustment (joint pose and landmark optimization)"
  files:
    - path: "core/slam/factors.py"
      object: "create_reprojection_factor"
    - path: "core/slam/camera.py"
      object: "compute_reprojection_error"
    - path: "ch7_slam/example_bundle_adjustment.py"
      object: "main"
  tests:
    - "tests/core/slam/test_camera.py::TestComputeReprojectionError"
  notes: "Eq. 7.68: BA cost function (sum of squared reprojection errors). Eq. 7.69: reprojection error definition. Eq. 7.70: robust kernel (optional)."

- eq: "Reprojection Error"
  chapter: 7
  description: "2D pixel error between observed and projected landmark"
  files:
    - path: "core/slam/camera.py"
      object: "compute_reprojection_error"
    - path: "core/slam/factors.py"
      object: "create_reprojection_factor"
  tests:
    - "tests/core/slam/test_camera.py::TestComputeReprojectionError"
  notes: "Error = projected_pixel - observed_pixel. Minimized in bundle adjustment to jointly refine camera poses and 3D landmark positions."

# ------------------------------------------------------------------------------
# SE(2) Operations (Supporting Functions)
# ------------------------------------------------------------------------------

- eq: "SE(2) Group Operations"
  chapter: 7
  description: "Special Euclidean Group SE(2) for 2D rigid body transformations"
  files:
    - path: "core/slam/se2.py"
      object: "se2_compose"
    - path: "core/slam/se2.py"
      object: "se2_inverse"
    - path: "core/slam/se2.py"
      object: "se2_apply"
    - path: "core/slam/se2.py"
      object: "se2_relative"
    - path: "core/slam/se2.py"
      object: "wrap_angle"
  tests:
    - "tests/core/slam/test_se2.py"
  notes: "Core 2D transformation algebra for SLAM. Pose = [x, y, yaw]. Operations: compose (⊕), inverse (⁻¹), apply to points, relative pose."

# ==============================================================================
# Chapter 8: Sensor Fusion (Placeholder)
# ==============================================================================
# To be added when Chapter 8 sensor fusion is implemented

