# Equation Index: Book Equations → Code Mapping
#
# This file maps equations from "Principles of Indoor Positioning and Indoor Navigation"
# to their implementations in the codebase.
#
# Format:
#   - eq: "Eq. (C.NN)"          # Equation identifier from book
#     chapter: N                 # Chapter number
#     description: "..."         # Brief description
#     files:                     # List of implementing files
#       - path: "..."            # File path
#         object: "..."          # Function/class name
#     tests:                     # List of test files (optional)
#       - "..."
#     notebooks:                 # List of notebooks (optional)
#       - "..."
#     notes: "..."               # Additional notes (optional)

# ==============================================================================
# Chapter 2: Coordinate Systems and Attitude Representations
# ==============================================================================

- eq: "Eq. (2.1)"
  chapter: 2
  description: "LLH to ECEF coordinate transformation"
  files:
    - path: "core/coords/transforms.py"
      object: "llh_to_ecef"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_transforms.py::TestLLHtoECEF"
    - "tests/core/coords/test_transforms.py::TestRoundTripLLHECEF"
  notes: "Uses WGS84 ellipsoid parameters. Closed-form solution."

- eq: "Eq. (2.2)"
  chapter: 2
  description: "ECEF to LLH coordinate transformation (iterative)"
  files:
    - path: "core/coords/transforms.py"
      object: "ecef_to_llh"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_transforms.py::TestECEFtoLLH"
    - "tests/core/coords/test_transforms.py::TestRoundTripLLHECEF"
  notes: "Iterative algorithm with configurable tolerance (default 1e-12 m). Handles poles as special case."

- eq: "Eq. (2.3)"
  chapter: 2
  description: "ECEF to ENU (East-North-Up) local frame transformation"
  files:
    - path: "core/coords/transforms.py"
      object: "ecef_to_enu"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_transforms.py::TestECEFtoENU"
    - "tests/core/coords/test_transforms.py::TestRoundTripECEFENU"
  notes: "Rotation matrix from ECEF to local tangent plane at reference point."

- eq: "Eq. (2.4)"
  chapter: 2
  description: "ENU to ECEF coordinate transformation"
  files:
    - path: "core/coords/transforms.py"
      object: "enu_to_ecef"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_transforms.py::TestENUtoECEF"
    - "tests/core/coords/test_transforms.py::TestRoundTripECEFENU"
  notes: "Inverse of ECEF to ENU transformation."

- eq: "Eq. (2.5)"
  chapter: 2
  description: "Euler angles to rotation matrix (ZYX convention)"
  files:
    - path: "core/coords/rotations.py"
      object: "euler_to_rotation_matrix"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestEulerToRotationMatrix"
    - "tests/core/coords/test_rotations.py::TestRoundTripEulerRotationMatrix"
  notes: "ZYX (yaw-pitch-roll) Euler angle convention. Returns proper orthogonal matrix in SO(3)."

- eq: "Eq. (2.6)"
  chapter: 2
  description: "Rotation matrix to Euler angles"
  files:
    - path: "core/coords/rotations.py"
      object: "rotation_matrix_to_euler"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestRotationMatrixToEuler"
    - "tests/core/coords/test_rotations.py::TestRoundTripEulerRotationMatrix"
  notes: "Handles gimbal lock at pitch = ±90° by setting roll = 0 by convention."

- eq: "Eq. (2.7)"
  chapter: 2
  description: "Euler angles to quaternion"
  files:
    - path: "core/coords/rotations.py"
      object: "euler_to_quat"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestEulerToQuaternion"
    - "tests/core/coords/test_rotations.py::TestRoundTripEulerQuaternion"
  notes: "Returns unit quaternion [qw, qx, qy, qz] with scalar-first convention."

- eq: "Eq. (2.8)"
  chapter: 2
  description: "Quaternion to Euler angles"
  files:
    - path: "core/coords/rotations.py"
      object: "quat_to_euler"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestQuaternionToEuler"
    - "tests/core/coords/test_rotations.py::TestRoundTripEulerQuaternion"
  notes: "Expects unit quaternion [qw, qx, qy, qz]. Clamps arcsin argument to [-1, 1]."

- eq: "Eq. (2.9)"
  chapter: 2
  description: "Quaternion to rotation matrix"
  files:
    - path: "core/coords/rotations.py"
      object: "quat_to_rotation_matrix"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestQuaternionToRotationMatrix"
    - "tests/core/coords/test_rotations.py::TestRoundTripQuaternionRotationMatrix"
  notes: "Returns proper orthogonal matrix. Assumes input quaternion is normalized."

- eq: "Eq. (2.10)"
  chapter: 2
  description: "Rotation matrix to quaternion (Shepperd's method)"
  files:
    - path: "core/coords/rotations.py"
      object: "rotation_matrix_to_quat"
    - path: "ch2_coords/example_coordinate_transforms.py"
      object: "main"
  tests:
    - "tests/core/coords/test_rotations.py::TestRotationMatrixToQuaternion"
    - "tests/core/coords/test_rotations.py::TestRoundTripQuaternionRotationMatrix"
  notes: "Uses Shepperd's method for numerical stability. Chooses largest diagonal element. Normalizes output."

# ==============================================================================
# Chapter 3: State Estimation and Filtering
# ==============================================================================

# ------------------------------------------------------------------------------
# Least Squares Methods
# ------------------------------------------------------------------------------

- eq: "Eq. (3.1)"
  chapter: 3
  description: "Standard Least Squares: x̂ = (A'A)⁻¹A'b"
  files:
    - path: "core/estimators/least_squares.py"
      object: "linear_least_squares"
    - path: "ch3_estimators/example_least_squares.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py::TestLinearLeastSquares"
  notes: "Solves overdetermined linear systems. Computes covariance P = σ²(A'A)⁻¹."

- eq: "Eq. (3.2)"
  chapter: 3
  description: "Weighted Least Squares: x̂ = (A'WA)⁻¹A'Wb"
  files:
    - path: "core/estimators/least_squares.py"
      object: "weighted_least_squares"
    - path: "ch3_estimators/example_least_squares.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py::TestWeightedLeastSquares"
  notes: "Weight matrix W typically R⁻¹ (inverse measurement covariance)."

- eq: "Eq. (3.3)"
  chapter: 3
  description: "Gauss-Newton Iterative Least Squares"
  files:
    - path: "core/estimators/least_squares.py"
      object: "iterative_least_squares"
    - path: "ch3_estimators/example_least_squares.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py::TestIterativeLeastSquares"
  notes: "For nonlinear problems: xₖ₊₁ = xₖ + (J'J)⁻¹J'r. Requires Jacobian function."

- eq: "Eq. (3.4)"
  chapter: 3
  description: "Robust Least Squares with M-estimators"
  files:
    - path: "core/estimators/least_squares.py"
      object: "robust_least_squares"
    - path: "ch3_estimators/example_least_squares.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py::TestRobustLeastSquares"
  notes: "IRLS with Huber, Cauchy, or Tukey loss functions. Downweights outliers."

# ------------------------------------------------------------------------------
# Kalman Filter
# ------------------------------------------------------------------------------

- eq: "Eqs. (3.11)-(3.12)"
  chapter: 3
  description: "Kalman Filter Prediction Step"
  files:
    - path: "core/estimators/kalman_filter.py"
      object: "KalmanFilter.predict"
    - path: "ch3_estimators/example_kalman_1d.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py"
  notes: "State prediction: x̄ₖ = Fxₖ₋₁ + Buₖ. Covariance: P̄ₖ = FPₖ₋₁F' + Q."

- eq: "Eqs. (3.17)-(3.19)"
  chapter: 3
  description: "Kalman Filter Update Step"
  files:
    - path: "core/estimators/kalman_filter.py"
      object: "KalmanFilter.update"
    - path: "ch3_estimators/example_kalman_1d.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py"
  notes: "State update: xₖ = x̄ₖ + K(z - Hx̄ₖ). Kalman gain: K = P̄H'(HP̄H' + R)⁻¹."

# ------------------------------------------------------------------------------
# Extended Kalman Filter
# ------------------------------------------------------------------------------

- eq: "Eqs. (3.21)-(3.22)"
  chapter: 3
  description: "Extended Kalman Filter (EKF)"
  files:
    - path: "core/estimators/extended_kalman_filter.py"
      object: "ExtendedKalmanFilter"
    - path: "ch3_estimators/example_ekf_range_bearing.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py"
  notes: "Nonlinear prediction/update with Jacobian linearization. For range-bearing positioning."

# ------------------------------------------------------------------------------
# Unscented Kalman Filter
# ------------------------------------------------------------------------------

- eq: "Eqs. (3.24)-(3.30)"
  chapter: 3
  description: "Unscented Kalman Filter (UKF)"
  files:
    - path: "core/estimators/unscented_kalman_filter.py"
      object: "UnscentedKalmanFilter"
    - path: "ch3_estimators/example_comparison.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py"
  notes: "Sigma point-based nonlinear filter. No Jacobians required."

# ------------------------------------------------------------------------------
# Particle Filter
# ------------------------------------------------------------------------------

- eq: "Eqs. (3.33)-(3.34)"
  chapter: 3
  description: "Particle Filter (Sequential Monte Carlo)"
  files:
    - path: "core/estimators/particle_filter.py"
      object: "ParticleFilter"
    - path: "ch3_estimators/example_comparison.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py"
  notes: "Monte Carlo approach for non-Gaussian distributions. Systematic resampling."

# ------------------------------------------------------------------------------
# Factor Graph Optimization
# ------------------------------------------------------------------------------

- eq: "Eqs. (3.35)-(3.43)"
  chapter: 3
  description: "Factor Graph Optimization (MAP estimation)"
  files:
    - path: "core/estimators/factor_graph.py"
      object: "FactorGraph"
    - path: "ch3_estimators/example_comparison.py"
      object: "main"
  tests:
    - "tests/core/estimators/test_least_squares.py"
  notes: "Batch optimization. Gauss-Newton and gradient descent solvers."

# ==============================================================================
# Chapter 4: RF Point Positioning by Radio Signals
# ==============================================================================

# TOA (Time of Arrival) Ranging
- eq: "Eq. (4.1)"
  chapter: 4
  description: "Basic TOA range measurement"
  files:
    - path: "core/rf/measurement_models.py"
      object: "toa_range"
    - path: "ch4_rf_point_positioning/example_toa_positioning.py"
      object: "demo_toa_basic"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestTOA::test_toa_range_2d"
    - "tests/core/rf/test_measurement_models.py::TestTOA::test_toa_range_3d"
  notes: "Distance = c * time_of_flight, where c is speed of light"

- eq: "Eq. (4.6)"
  chapter: 4
  description: "Two-way TOA (RTT) range measurement"
  files:
    - path: "core/rf/measurement_models.py"
      object: "two_way_toa_range"
    - path: "ch4_rf_point_positioning/example_toa_positioning.py"
      object: "demo_two_way_toa"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestTOA::test_two_way_toa"
  notes: "Round-trip time distance with optional processing delay correction"

# RSS (Received Signal Strength) Ranging
- eq: "Eq. (4.11)"
  chapter: 4
  description: "Path-loss model for RSS measurements"
  files:
    - path: "core/rf/measurement_models.py"
      object: "rss_pathloss"
    - path: "ch4_rf_point_positioning/example_comparison.py"
      object: "rss_positioning_test"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestRSS::test_rss_pathloss"
  notes: "RSS = Ptx - 10*n*log10(d/d0) - X_sigma, where n is path-loss exponent"

- eq: "Eq. (4.13)"
  chapter: 4
  description: "RSS to distance conversion"
  files:
    - path: "core/rf/measurement_models.py"
      object: "rss_to_distance"
    - path: "ch4_rf_point_positioning/example_comparison.py"
      object: "rss_positioning_test"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestRSS::test_rss_to_distance"
  notes: "Inverts path-loss model to estimate distance from RSS"

# TOA Positioning Algorithms
- eq: "Eqs. (4.14)-(4.23)"
  chapter: 4
  description: "Nonlinear TOA I-WLS (Iterative Weighted Least Squares)"
  files:
    - path: "core/rf/positioning.py"
      object: "TOAPositioner"
    - path: "ch4_rf_point_positioning/example_toa_positioning.py"
      object: "demo_toa_basic"
  tests:
    - "tests/core/rf/test_positioning.py::TestTOAPositioner"
  notes: "Iterative Gauss-Newton with weighting. Requires initial guess."

- eq: "Eqs. (4.24)-(4.26)"
  chapter: 4
  description: "TOA positioning with joint clock bias estimation"
  files:
    - path: "core/rf/positioning.py"
      object: "toa_solve_with_clock_bias"
    - path: "ch4_rf_point_positioning/example_toa_positioning.py"
      object: "demo_toa_with_clock_bias"
  tests:
    - "tests/core/rf/test_positioning.py::TestTOAPositioner::test_with_clock_bias"
  notes: "Extended state vector [x, y, clock_bias] for joint estimation"

# TDOA (Time Difference of Arrival)
- eq: "Eqs. (4.27)-(4.33)"
  chapter: 4
  description: "TDOA range difference measurements"
  files:
    - path: "core/rf/measurement_models.py"
      object: "tdoa_range_difference"
    - path: "core/rf/measurement_models.py"
      object: "tdoa_measurement_vector"
    - path: "ch4_rf_point_positioning/example_tdoa_positioning.py"
      object: "demo_tdoa_basic"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestTDOA"
  notes: "TDOA = range_i - range_ref eliminates receiver clock bias"

- eq: "Eqs. (4.34)-(4.42)"
  chapter: 4
  description: "TDOA I-WLS positioning algorithm"
  files:
    - path: "core/rf/positioning.py"
      object: "TDOAPositioner"
    - path: "ch4_rf_point_positioning/example_tdoa_positioning.py"
      object: "demo_tdoa_basic"
  tests:
    - "tests/core/rf/test_positioning.py::TestTDOAPositioner"
  notes: "Linearized TDOA with iterative weighted least squares"

- eq: "Eqs. (4.43)-(4.48)"
  chapter: 4
  description: "Fang's closed-form TDOA algorithm"
  files:
    - path: "core/rf/positioning.py"
      object: "tdoa_fang_solver"
    - path: "ch4_rf_point_positioning/example_tdoa_positioning.py"
      object: "demo_closed_form_algorithms"
  tests:
    - "tests/core/rf/test_positioning.py::TestTDOAPositioner::test_fang_solver"
  notes: "Closed-form hyperbolic TDOA solution (4 anchors minimum)"

- eq: "Eq. (4.58)"
  chapter: 4
  description: "Chan's two-step TDOA algorithm"
  files:
    - path: "core/rf/positioning.py"
      object: "tdoa_chan_solver"
    - path: "ch4_rf_point_positioning/example_tdoa_positioning.py"
      object: "demo_closed_form_algorithms"
  tests:
    - "tests/core/rf/test_positioning.py::TestTDOAPositioner::test_chan_solver"
  notes: "Two-step WLS refinement with covariance weighting"

# AOA (Angle of Arrival)
- eq: "Eqs. (4.63)-(4.67)"
  chapter: 4
  description: "AOA azimuth and elevation measurements"
  files:
    - path: "core/rf/measurement_models.py"
      object: "aoa_azimuth"
    - path: "core/rf/measurement_models.py"
      object: "aoa_elevation"
    - path: "core/rf/measurement_models.py"
      object: "aoa_measurement_vector"
    - path: "ch4_rf_point_positioning/example_aoa_positioning.py"
      object: "demo_aoa_basic"
  tests:
    - "tests/core/rf/test_measurement_models.py::TestAOA"
  notes: "Azimuth = atan2(dy, dx), Elevation = atan2(dz, sqrt(dx^2+dy^2))"

- eq: "Eqs. (4.63)-(4.67)"
  chapter: 4
  description: "AOA I-WLS positioning algorithm"
  files:
    - path: "core/rf/positioning.py"
      object: "AOAPositioner"
    - path: "ch4_rf_point_positioning/example_aoa_positioning.py"
      object: "demo_aoa_basic"
  tests:
    - "tests/core/rf/test_positioning.py::TestAOAPositioner"
  notes: "Iterative weighted least squares for AOA positioning"

- eq: "Eq. (4.68)"
  chapter: 4
  description: "OVE (Optimal Velocity Estimator) for AOA"
  files:
    - path: "core/rf/positioning.py"
      object: "aoa_ove_solver"
    - path: "ch4_rf_point_positioning/example_aoa_positioning.py"
      object: "demo_closed_form_algorithms"
  tests:
    - "tests/core/rf/test_positioning.py::TestAOAPositioner::test_ove_solver"
  notes: "Closed-form AOA positioning algorithm (minimum 3 anchors)"

- eq: "Eq. (4.69)"
  chapter: 4
  description: "3D PLE (Position Line Estimation) for AOA"
  files:
    - path: "core/rf/positioning.py"
      object: "aoa_3dple_solver"
    - path: "ch4_rf_point_positioning/example_aoa_positioning.py"
      object: "demo_closed_form_algorithms"
  tests:
    - "tests/core/rf/test_positioning.py::TestAOAPositioner::test_3dple_solver"
  notes: "3D position line estimation for AOA (minimum 3 anchors)"

# DOP (Dilution of Precision)
- eq: "Section 4.5"
  chapter: 4
  description: "DOP computation (GDOP, PDOP, HDOP, VDOP)"
  files:
    - path: "core/rf/dop.py"
      object: "compute_dop"
    - path: "core/rf/dop.py"
      object: "compute_geometry_matrix"
    - path: "core/rf/dop.py"
      object: "compute_dop_map"
  tests:
    - "tests/core/rf/test_dop.py"
  notes: "Geometry matrix and DOP metrics for evaluating positioning quality"

# ==============================================================================
# Chapter 5: Fingerprinting-based Indoor Positioning
# ==============================================================================

# ------------------------------------------------------------------------------
# Deterministic Fingerprinting
# ------------------------------------------------------------------------------

- eq: "Eq. (5.1)"
  chapter: 5
  description: "Nearest-Neighbor (NN) fingerprinting"
  files:
    - path: "core/fingerprinting/deterministic.py"
      object: "nn_localize"
    - path: "ch5_fingerprinting/example_deterministic.py"
      object: "main"
  tests:
    - "tests/core/fingerprinting/test_deterministic.py"
  notes: "Decision rule: i* = argmin_i D(z, f_i). Returns location of nearest RP."

- eq: "Eq. (5.2)"
  chapter: 5
  description: "k-Nearest-Neighbor (k-NN) fingerprinting"
  files:
    - path: "core/fingerprinting/deterministic.py"
      object: "knn_localize"
    - path: "ch5_fingerprinting/example_deterministic.py"
      object: "main"
  tests:
    - "tests/core/fingerprinting/test_deterministic.py"
  notes: "Weighted average: x̂ = Σ w_i x_i / Σ w_i. Supports inverse distance and uniform weighting."

# ------------------------------------------------------------------------------
# Probabilistic Fingerprinting
# ------------------------------------------------------------------------------

- eq: "Eq. (5.3)"
  chapter: 5
  description: "Log-likelihood under Gaussian Naive Bayes"
  files:
    - path: "core/fingerprinting/probabilistic.py"
      object: "log_likelihood"
    - path: "ch5_fingerprinting/example_probabilistic.py"
      object: "main"
  tests:
    - "tests/core/fingerprinting/test_probabilistic.py"
  notes: "Log p(z|x_i) = Σ_j log N(z_j; μ_ij, σ_ij²). Assumes feature independence."

- eq: "Eq. (5.4)"
  chapter: 5
  description: "Maximum A Posteriori (MAP) localization"
  files:
    - path: "core/fingerprinting/probabilistic.py"
      object: "map_localize"
    - path: "ch5_fingerprinting/example_probabilistic.py"
      object: "main"
  tests:
    - "tests/core/fingerprinting/test_probabilistic.py"
  notes: "MAP: i* = argmax_i p(x_i|z). Returns discrete position estimate."

- eq: "Eq. (5.5)"
  chapter: 5
  description: "Posterior mean localization"
  files:
    - path: "core/fingerprinting/probabilistic.py"
      object: "posterior_mean_localize"
    - path: "ch5_fingerprinting/example_probabilistic.py"
      object: "main"
  tests:
    - "tests/core/fingerprinting/test_probabilistic.py"
  notes: "Posterior mean: x̂ = Σ p(x_i|z) x_i. Returns continuous position estimate."

# ------------------------------------------------------------------------------
# Pattern Recognition
# ------------------------------------------------------------------------------

- eq: "Linear Regression Model"
  chapter: 5
  description: "Linear regression localizer (ridge regression)"
  files:
    - path: "core/fingerprinting/pattern_recognition.py"
      object: "LinearRegressionLocalizer"
    - path: "ch5_fingerprinting/example_pattern_recognition.py"
      object: "main"
  tests:
    - "tests/core/fingerprinting/test_pattern_recognition.py"
  notes: "Direct regression: x̂ = Wz + b. Ridge regularization prevents overfitting."

# ==============================================================================
# Chapter 6: Dead Reckoning and Proprioceptive Sensors
# ==============================================================================

# ------------------------------------------------------------------------------
# IMU Strapdown Integration
# ------------------------------------------------------------------------------

- eq: "Eqs. (6.2)-(6.4)"
  chapter: 6
  description: "Quaternion attitude integration"
  files:
    - path: "core/sensors/strapdown.py"
      object: "quat_integrate"
    - path: "ch6_dead_reckoning/example_imu_strapdown.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_strapdown.py"
  notes: "Discrete quaternion integration: q_k = q_{k-1} + ½Ω(ω)q_{k-1}Δt"

- eq: "Eq. (6.3)"
  chapter: 6
  description: "Ω(ω) skew-symmetric matrix for quaternion kinematics"
  files:
    - path: "core/sensors/strapdown.py"
      object: "omega_matrix"
  tests:
    - "tests/core/sensors/test_sensors_strapdown.py"
  notes: "4×4 matrix for quaternion differential equation: q̇ = ½Ω(ω)q"

- eq: "Eq. (6.6)"
  chapter: 6
  description: "Gyroscope error correction"
  files:
    - path: "core/sensors/imu_models.py"
      object: "correct_gyro"
  tests:
    - "tests/core/sensors/test_sensors_imu_models.py"
  notes: "Corrected angular rate: ω = ω̃ - b_g - n_g"

- eq: "Eq. (6.7)"
  chapter: 6
  description: "Velocity integration"
  files:
    - path: "core/sensors/strapdown.py"
      object: "vel_update"
    - path: "ch6_dead_reckoning/example_imu_strapdown.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_strapdown.py"
  notes: "Velocity update: v_k = v_{k-1} + (C_B^M f_b + g)Δt"

- eq: "Eq. (6.8)"
  chapter: 6
  description: "Gravity vector in map frame"
  files:
    - path: "core/sensors/strapdown.py"
      object: "gravity_vector"
  tests:
    - "tests/core/sensors/test_sensors_strapdown.py"
  notes: "g = [0, 0, -9.81]^T in ENU frame"

- eq: "Eq. (6.9)"
  chapter: 6
  description: "Accelerometer error correction"
  files:
    - path: "core/sensors/imu_models.py"
      object: "correct_accel"
  tests:
    - "tests/core/sensors/test_sensors_imu_models.py"
  notes: "Corrected specific force: f = f̃ - b_a - n_a"

- eq: "Eq. (6.10)"
  chapter: 6
  description: "Position integration"
  files:
    - path: "core/sensors/strapdown.py"
      object: "pos_update"
    - path: "ch6_dead_reckoning/example_imu_strapdown.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_strapdown.py"
  notes: "Position update: p_k = p_{k-1} + v_k Δt"

# ------------------------------------------------------------------------------
# Wheel Odometry
# ------------------------------------------------------------------------------

- eq: "Eq. (6.11)"
  chapter: 6
  description: "Lever arm compensation for wheel odometry"
  files:
    - path: "core/sensors/wheel_odometry.py"
      object: "wheel_speed_to_attitude_velocity"
    - path: "ch6_dead_reckoning/example_wheel_odometry.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_wheel_odometry.py"
  notes: "v^A = v^S + [ω^B×]r^B. Compensates for IMU offset from wheel."

- eq: "Eq. (6.12)"
  chapter: 6
  description: "Skew-symmetric matrix for cross product"
  files:
    - path: "core/sensors/wheel_odometry.py"
      object: "skew"
  tests:
    - "tests/core/sensors/test_sensors_wheel_odometry.py"
  notes: "[v×] matrix such that [v×]u = v × u"

- eq: "Eq. (6.14)"
  chapter: 6
  description: "Velocity frame transformation"
  files:
    - path: "core/sensors/wheel_odometry.py"
      object: "attitude_to_map_velocity"
  tests:
    - "tests/core/sensors/test_sensors_wheel_odometry.py"
  notes: "v^M = C_A^M(q) v^A. Transforms velocity to map frame."

- eq: "Eq. (6.15)"
  chapter: 6
  description: "Wheel odometry position update"
  files:
    - path: "core/sensors/wheel_odometry.py"
      object: "odom_pos_update"
    - path: "ch6_dead_reckoning/example_wheel_odometry.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_wheel_odometry.py"
  notes: "p_k^M = p_{k-1}^M + v_k^M Δt"

# ------------------------------------------------------------------------------
# Drift Correction Constraints
# ------------------------------------------------------------------------------

- eq: "Eq. (6.44)"
  chapter: 6
  description: "Zero velocity (ZUPT) detector"
  files:
    - path: "core/sensors/constraints.py"
      object: "detect_zupt"
    - path: "ch6_dead_reckoning/example_zupt.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_constraints.py"
  notes: "Detects stationary periods: |Δω| < δ_ω AND |Δf - g| < δ_f"

- eq: "Eq. (6.45)"
  chapter: 6
  description: "ZUPT pseudo-measurement"
  files:
    - path: "core/sensors/constraints.py"
      object: "ZuptMeasurementModel"
    - path: "ch6_dead_reckoning/example_zupt.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_constraints.py"
  notes: "h(x) = v. Constrains velocity to zero during stationary periods."

- eq: "Eq. (6.60)"
  chapter: 6
  description: "ZARU (Zero Angular Rate Update) pseudo-measurement"
  files:
    - path: "core/sensors/constraints.py"
      object: "ZaruMeasurementModel"
  tests:
    - "tests/core/sensors/test_sensors_constraints.py"
  notes: "h(x) = ω. Constrains angular rate to zero when stationary."

- eq: "Eq. (6.61)"
  chapter: 6
  description: "NHC (Non-Holonomic Constraint) pseudo-measurement"
  files:
    - path: "core/sensors/constraints.py"
      object: "NhcMeasurementModel"
  tests:
    - "tests/core/sensors/test_sensors_constraints.py"
  notes: "h(x) = C_B^M^T v. Constrains lateral/vertical velocity to zero for vehicles."

# ------------------------------------------------------------------------------
# Pedestrian Dead Reckoning (PDR)
# ------------------------------------------------------------------------------

- eq: "Eq. (6.46)"
  chapter: 6
  description: "Total acceleration magnitude"
  files:
    - path: "core/sensors/pdr.py"
      object: "total_accel_magnitude"
    - path: "ch6_dead_reckoning/example_pdr.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_pdr.py"
  notes: "a_mag = ||a||. Used for step detection."

- eq: "Eq. (6.47)"
  chapter: 6
  description: "Remove gravity from acceleration magnitude"
  files:
    - path: "core/sensors/pdr.py"
      object: "remove_gravity_from_magnitude"
  tests:
    - "tests/core/sensors/test_sensors_pdr.py"
  notes: "a_dyn = a_mag - g. Isolates dynamic acceleration component."

- eq: "Eq. (6.48)"
  chapter: 6
  description: "Step frequency estimation"
  files:
    - path: "core/sensors/pdr.py"
      object: "step_frequency"
  tests:
    - "tests/core/sensors/test_sensors_pdr.py"
  notes: "f_step = 1/Δt. Computed from step detection timing."

- eq: "Eq. (6.49)"
  chapter: 6
  description: "Weinberg step length model"
  files:
    - path: "core/sensors/pdr.py"
      object: "step_length"
    - path: "ch6_dead_reckoning/example_pdr.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_pdr.py"
  notes: "L = c·h^a·f_step^b. Empirical model based on height and cadence."

- eq: "Eq. (6.50)"
  chapter: 6
  description: "PDR position update"
  files:
    - path: "core/sensors/pdr.py"
      object: "pdr_step_update"
    - path: "ch6_dead_reckoning/example_pdr.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_pdr.py"
  notes: "p_k = p_{k-1} + L[cos(ψ), sin(ψ)]^T. 2D step-and-heading update."

# ------------------------------------------------------------------------------
# Environmental Sensors
# ------------------------------------------------------------------------------

- eq: "Eqs. (6.51)-(6.53)"
  chapter: 6
  description: "Magnetometer heading computation"
  files:
    - path: "core/sensors/environment.py"
      object: "mag_heading"
    - path: "ch6_dead_reckoning/example_environment.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_environment.py"
  notes: "ψ = atan2(mag_hy, mag_hx) + declination. With tilt compensation."

- eq: "Eq. (6.52)"
  chapter: 6
  description: "Magnetometer tilt compensation"
  files:
    - path: "core/sensors/environment.py"
      object: "mag_tilt_compensate"
  tests:
    - "tests/core/sensors/test_sensors_environment.py"
  notes: "mag_h = R_y(-pitch)·R_x(-roll)·mag_b. Projects to horizontal plane."

- eq: "Eq. (6.54)"
  chapter: 6
  description: "Barometric altitude from pressure"
  files:
    - path: "core/sensors/environment.py"
      object: "pressure_to_altitude"
    - path: "ch6_dead_reckoning/example_environment.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_environment.py"
  notes: "h = (T/L)(1 - (p/p₀)^α). International barometric formula."

- eq: "Eq. (6.55)"
  chapter: 6
  description: "Exponential smoothing filter"
  files:
    - path: "core/sensors/environment.py"
      object: "smooth_measurement_simple"
  tests:
    - "tests/core/sensors/test_sensors_environment.py"
  notes: "x_k = (1-α)x_{k-1} + αz_k. Simple low-pass filter."

# ------------------------------------------------------------------------------
# IMU Calibration
# ------------------------------------------------------------------------------

- eq: "Eqs. (6.56)-(6.58)"
  chapter: 6
  description: "Allan variance for IMU noise characterization"
  files:
    - path: "core/sensors/calibration.py"
      object: "allan_variance"
    - path: "core/sensors/calibration.py"
      object: "characterize_imu_noise"
    - path: "ch6_dead_reckoning/example_allan_variance.py"
      object: "main"
  tests:
    - "tests/core/sensors/test_sensors_calibration.py"
  notes: "σ²(τ) = ½E[(θ̄_{k+1} - θ̄_k)²]. Identifies ARW, bias instability, RRW."

- eq: "Eq. (6.59)"
  chapter: 6
  description: "IMU scale factor and misalignment correction"
  files:
    - path: "core/sensors/imu_models.py"
      object: "apply_imu_scale_misalignment"
  tests:
    - "tests/core/sensors/test_sensors_imu_models.py"
  notes: "u_corrected = M·S·(u_meas - b). Full sensor error model."

# ==============================================================================
# Chapter 7: SLAM Technologies
# ==============================================================================

# ------------------------------------------------------------------------------
# Section 7.2.1: ICP (Iterative Closest Point) Scan Matching
# ------------------------------------------------------------------------------

- eq: "Eq. (7.10)"
  chapter: 7
  description: "ICP point-to-point matching objective (sum of squared distances)"
  files:
    - path: "core/slam/scan_matching.py"
      object: "compute_icp_residual"
    - path: "core/slam/scan_matching.py"
      object: "icp_point_to_point"
    - path: "ch7_slam/example_pose_graph_slam.py"
      object: "detect_loop_closures_icp"
  tests:
    - "tests/core/slam/test_scan_matching.py::TestComputeICPResidual"
    - "tests/core/slam/test_scan_matching.py::TestICPPointToPoint"
  notes: "Minimizes sum of squared Euclidean distances between corresponding points. Iterative algorithm with SVD-based rigid transform update."

- eq: "Eq. (7.11)"
  chapter: 7
  description: "ICP correspondence association with distance threshold"
  files:
    - path: "core/slam/scan_matching.py"
      object: "find_correspondences"
    - path: "core/slam/scan_matching.py"
      object: "icp_point_to_point"
  tests:
    - "tests/core/slam/test_scan_matching.py::TestFindCorrespondences"
    - "tests/core/slam/test_scan_matching.py::TestICPPointToPoint::test_max_correspondence_distance"
  notes: "Nearest-neighbor correspondence search with max_distance threshold (epsilon). Uses KD-tree for efficiency."

- eq: "SVD-based rigid alignment"
  chapter: 7
  description: "SVD (Singular Value Decomposition) for optimal rigid body transformation"
  files:
    - path: "core/slam/scan_matching.py"
      object: "align_svd"
  tests:
    - "tests/core/slam/test_scan_matching.py::TestAlignSVD"
  notes: "Computes optimal [x, y, yaw] transformation between matched point clouds using SVD (Procrustes problem). Core update step in ICP."

# ------------------------------------------------------------------------------
# Section 7.2.2: NDT (Normal Distributions Transform) Scan Matching
# ------------------------------------------------------------------------------

- eq: "Eqs. (7.12)-(7.13)"
  chapter: 7
  description: "NDT voxel statistics (mean and covariance per voxel)"
  files:
    - path: "core/slam/ndt.py"
      object: "build_ndt_map"
  tests:
    - "tests/core/slam/test_ndt.py::TestBuildNDTMap"
  notes: "Computes per-voxel Gaussian distribution (mean μ_k and covariance Σ_k) from point cloud. Requires minimum points per voxel."

- eq: "Eqs. (7.14)-(7.15)"
  chapter: 7
  description: "NDT negative log-likelihood (score function)"
  files:
    - path: "core/slam/ndt.py"
      object: "ndt_score"
  tests:
    - "tests/core/slam/test_ndt.py::TestNDTScore"
  notes: "Computes negative log-likelihood of transformed scan under NDT map Gaussian distributions. Lower score = better alignment."

- eq: "Eq. (7.16)"
  chapter: 7
  description: "NDT alignment via MLE optimization"
  files:
    - path: "core/slam/ndt.py"
      object: "ndt_align"
    - path: "core/slam/ndt.py"
      object: "ndt_gradient"
  tests:
    - "tests/core/slam/test_ndt.py::TestNDTAlign"
    - "tests/core/slam/test_ndt.py::TestNDTGradient"
  notes: "Optimizes pose to maximize likelihood (minimize negative log-likelihood). Uses gradient descent with numerical derivatives."

# ------------------------------------------------------------------------------
# Section 7.3: Pose Graph Optimization
# ------------------------------------------------------------------------------

- eq: "Section 7.3 (Pose Graph Framework)"
  chapter: 7
  description: "Pose graph optimization with odometry and loop closure factors"
  files:
    - path: "core/slam/factors.py"
      object: "create_pose_graph"
    - path: "core/slam/factors.py"
      object: "create_odometry_factor"
    - path: "core/slam/factors.py"
      object: "create_loop_closure_factor"
    - path: "core/slam/factors.py"
      object: "create_prior_factor"
    - path: "ch7_slam/example_pose_graph_slam.py"
      object: "main"
  tests:
    - "tests/core/slam/test_factors.py::TestPoseGraphCreation"
    - "tests/core/slam/test_factors.py::TestIntegration::test_full_slam_scenario"
  notes: "Complete pose graph SLAM: odometry factors connect consecutive poses, loop closure factors reduce drift, prior anchors first pose."

- eq: "Odometry Factor (SE(2) relative pose)"
  chapter: 7
  description: "Binary factor for odometry constraint between consecutive poses"
  files:
    - path: "core/slam/factors.py"
      object: "create_odometry_factor"
  tests:
    - "tests/core/slam/test_factors.py::TestOdometryFactor"
  notes: "Residual: r = (x_i^-1 ⊕ x_j) - z_ij, where z_ij is measured relative pose. Uses SE(2) operations."

- eq: "Loop Closure Factor"
  chapter: 7
  description: "Binary factor for loop closure constraint (from scan matching)"
  files:
    - path: "core/slam/factors.py"
      object: "create_loop_closure_factor"
  tests:
    - "tests/core/slam/test_factors.py::TestLoopClosureFactor"
  notes: "Structurally identical to odometry factor but connects non-consecutive poses. Information matrix from ICP/NDT covariance."

- eq: "Prior Factor"
  chapter: 7
  description: "Unary factor to anchor pose to known value"
  files:
    - path: "core/slam/factors.py"
      object: "create_prior_factor"
  tests:
    - "tests/core/slam/test_factors.py::TestPriorFactor"
  notes: "Residual: r = x - x_prior. Used to fix first pose (preventing gauge freedom) or incorporate GPS measurements."

- eq: "Landmark Factor (range-bearing)"
  chapter: 7
  description: "Binary factor connecting pose to landmark via range-bearing measurement"
  files:
    - path: "core/slam/factors.py"
      object: "create_landmark_factor"
  tests:
    - "tests/core/slam/test_factors.py::TestLandmarkFactor"
  notes: "For feature-based SLAM. Residual: r = h(x_i, l_k) - z_ik where h is range-bearing measurement model."

# ------------------------------------------------------------------------------
# Section 7.4: Visual SLAM - Camera Model
# ------------------------------------------------------------------------------

- eq: "Eq. (7.40)"
  chapter: 7
  description: "Pinhole camera projection (3D point to pixel coordinates)"
  files:
    - path: "core/slam/camera.py"
      object: "project_point"
  tests:
    - "tests/core/slam/test_camera.py::TestProjectPoint"
  notes: "Full projection: normalize to z=1, apply distortion, scale by intrinsics. u = fx*x_d + cx, v = fy*y_d + cy."

- eq: "Eqs. (7.43)-(7.46)"
  chapter: 7
  description: "Brown-Conrady lens distortion model (radial + tangential)"
  files:
    - path: "core/slam/camera.py"
      object: "distort_normalized"
    - path: "core/slam/camera.py"
      object: "undistort_normalized"
    - path: "core/slam/camera.py"
      object: "project_point"
  tests:
    - "tests/core/slam/test_camera.py::TestDistortNormalized"
    - "tests/core/slam/test_camera.py::TestUndistortNormalized"
  notes: "Radial distortion (k1, k2) and tangential distortion (p1, p2). Eq. 7.43: radial component. Eqs. 7.44-7.45: tangential. Eq. 7.46: combined."

- eq: "Inverse Projection"
  chapter: 7
  description: "Pixel to 3D ray (inverse of projection)"
  files:
    - path: "core/slam/camera.py"
      object: "unproject_pixel"
  tests:
    - "tests/core/slam/test_camera.py::TestUnprojectPixel"
  notes: "Inverts camera model: pixel → undistort → normalize → 3D ray. Optional depth parameter gives 3D point."

# ------------------------------------------------------------------------------
# Section 7.4: Visual SLAM - Bundle Adjustment
# ------------------------------------------------------------------------------

- eq: "Eqs. (7.68)-(7.70)"
  chapter: 7
  description: "Bundle adjustment (joint pose and landmark optimization)"
  files:
    - path: "core/slam/factors.py"
      object: "create_reprojection_factor"
    - path: "core/slam/camera.py"
      object: "compute_reprojection_error"
    - path: "ch7_slam/example_bundle_adjustment.py"
      object: "main"
  tests:
    - "tests/core/slam/test_camera.py::TestComputeReprojectionError"
  notes: "Eq. 7.68: BA cost function (sum of squared reprojection errors). Eq. 7.69: reprojection error definition. Eq. 7.70: robust kernel (optional)."

- eq: "Reprojection Error"
  chapter: 7
  description: "2D pixel error between observed and projected landmark"
  files:
    - path: "core/slam/camera.py"
      object: "compute_reprojection_error"
    - path: "core/slam/factors.py"
      object: "create_reprojection_factor"
  tests:
    - "tests/core/slam/test_camera.py::TestComputeReprojectionError"
  notes: "Error = projected_pixel - observed_pixel. Minimized in bundle adjustment to jointly refine camera poses and 3D landmark positions."

# ------------------------------------------------------------------------------
# SE(2) Operations (Supporting Functions)
# ------------------------------------------------------------------------------

- eq: "SE(2) Group Operations"
  chapter: 7
  description: "Special Euclidean Group SE(2) for 2D rigid body transformations"
  files:
    - path: "core/slam/se2.py"
      object: "se2_compose"
    - path: "core/slam/se2.py"
      object: "se2_inverse"
    - path: "core/slam/se2.py"
      object: "se2_apply"
    - path: "core/slam/se2.py"
      object: "se2_relative"
    - path: "core/slam/se2.py"
      object: "wrap_angle"
  tests:
    - "tests/core/slam/test_se2.py"
  notes: "Core 2D transformation algebra for SLAM. Pose = [x, y, yaw]. Operations: compose (⊕), inverse (⁻¹), apply to points, relative pose."

# ==============================================================================
# Chapter 8: Sensor Fusion
# ==============================================================================

# ------------------------------------------------------------------------------
# Innovation Monitoring and Gating
# ------------------------------------------------------------------------------

- eq: "Eqs. (8.5)-(8.6)"
  chapter: 8
  description: "Innovation (measurement residual) computation"
  files:
    - path: "core/fusion/gating.py"
      object: "compute_innovation"
    - path: "ch8_sensor_fusion/tc_uwb_imu_ekf.py"
      object: "main"
  tests:
    - "tests/core/fusion/test_fusion_gating.py"
  notes: "Innovation: ν = z - h(x̄). Innovation covariance: S = HPH' + R."

- eq: "Eq. (8.9)"
  chapter: 8
  description: "Chi-square innovation gating"
  files:
    - path: "core/fusion/gating.py"
      object: "chi_square_gate"
    - path: "ch8_sensor_fusion/tc_uwb_imu_ekf.py"
      object: "main"
  tests:
    - "tests/core/fusion/test_fusion_gating.py"
  notes: "Test statistic: γ = ν'S⁻¹ν ~ χ²(m). Rejects measurements exceeding threshold."

# ------------------------------------------------------------------------------
# Tightly Coupled Fusion
# ------------------------------------------------------------------------------

- eq: "TC IMU+UWB Fusion"
  chapter: 8
  description: "Tightly coupled IMU + UWB range fusion"
  files:
    - path: "ch8_sensor_fusion/tc_uwb_imu_ekf.py"
      object: "main"
    - path: "ch8_sensor_fusion/tc_models.py"
      object: "create_process_model"
    - path: "ch8_sensor_fusion/tc_models.py"
      object: "create_uwb_range_measurement_model"
  tests:
    - "tests/core/fusion/test_fusion_types.py"
  notes: "Fuses raw UWB range measurements directly. 5D state: [px, py, vx, vy, yaw]."

# ------------------------------------------------------------------------------
# Loosely Coupled Fusion
# ------------------------------------------------------------------------------

- eq: "LC IMU+UWB Fusion"
  chapter: 8
  description: "Loosely coupled IMU + UWB position fusion"
  files:
    - path: "ch8_sensor_fusion/lc_uwb_imu_ekf.py"
      object: "main"
    - path: "ch8_sensor_fusion/lc_models.py"
      object: "create_process_model"
    - path: "ch8_sensor_fusion/lc_models.py"
      object: "create_position_measurement_model"
  tests:
    - "tests/core/fusion/test_fusion_types.py"
  notes: "Fuses pre-computed UWB position fixes. Simpler than TC but loses information."

# ------------------------------------------------------------------------------
# LC vs TC Comparison
# ------------------------------------------------------------------------------

- eq: "LC vs TC Comparison"
  chapter: 8
  description: "Comparison tool for loosely vs tightly coupled fusion"
  files:
    - path: "ch8_sensor_fusion/compare_lc_tc.py"
      object: "main"
  tests:
    - "tests/core/fusion/test_fusion_types.py"
  notes: "Demonstrates advantages of TC: better accuracy with partial observations, natural multi-rate handling."

# ------------------------------------------------------------------------------
# Observability Analysis
# ------------------------------------------------------------------------------

- eq: "Observability Analysis"
  chapter: 8
  description: "Observability Gramian and rank analysis"
  files:
    - path: "ch8_sensor_fusion/observability_demo.py"
      object: "main"
  tests:
    - "tests/core/fusion/test_fusion_types.py"
  notes: "Demonstrates observable vs unobservable states for different anchor configurations."

# ------------------------------------------------------------------------------
# Robust Measurement Handling
# ------------------------------------------------------------------------------

- eq: "Robust Fusion"
  chapter: 8
  description: "Robust measurement down-weighting for NLOS"
  files:
    - path: "ch8_sensor_fusion/tuning_robust_demo.py"
      object: "main"
    - path: "core/fusion/tuning.py"
      object: "huber_weight"
  tests:
    - "tests/core/fusion/test_fusion_tuning.py"
  notes: "Huber-based down-weighting for outlier measurements. Handles NLOS bias."

# ------------------------------------------------------------------------------
# Temporal Calibration
# ------------------------------------------------------------------------------

- eq: "Temporal Calibration"
  chapter: 8
  description: "Time offset estimation between sensors"
  files:
    - path: "ch8_sensor_fusion/temporal_calibration_demo.py"
      object: "main"
  tests:
    - "tests/core/fusion/test_fusion_types.py"
  notes: "Demonstrates effect of time synchronization errors and calibration methods."
