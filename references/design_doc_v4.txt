1. Project Overview
1.1 Purpose

This repository provides open-source, simulation-based examples of the algorithms in Principles of Indoor Positioning and Indoor Navigation (Chapters 2‚Äì8).

The repo is intended as a companion to the book: readers can read the equations and derivations in the text and then run concrete, minimal code examples that directly implement those equations on simulated datasets.

1.2 Target Users

Master‚Äôs students in navigation / robotics / geodesy / EE / CS.

PhD students and early-career researchers entering indoor positioning.

Engineers who want a reference implementation of classical algorithms before building production systems.

1.3 Goals

The repo should:

Demonstrate key algorithms from Ch.2‚Äì8 on small, reproducible simulations:

Ch.2: coordinate systems & attitude.

Ch.3: LS/WLS, robust LS, KF/EKF/UKF/PF, FGO.

Ch.4‚Äì7: RF positioning, fingerprinting, PDR/sensors, SLAM.

Ch.8: practical sensor fusion.

Provide reproducible experiments based on open simulation datasets.

Offer simple, inspectable reference implementations rather than production systems.

Support per-chapter examples that map back to the book.

New Goal: Equation-Level Traceability

For every important equation in the book that is implemented in code, there must be a clear mapping:

Book ‚Üí Code

For a given equation number (e.g. Eq. (3.12)), users can quickly locate:

The implementing function/class.

The tests and example notebooks that exercise it.

Code ‚Üí Book

From a function or class, users can see:

Which equation(s) it implements.

The chapter/section context.

Design constraints:

Mapping must be:

Searchable via plain text (e.g. searching Eq. (3.12) in the repo).

Maintainable when new code is added.

Visible in docstrings, comments, docs, and notebooks.

1.4 Out of Scope

Advanced techniques from Chapter 9 (crowdsourcing, collaborative, deep AI PDR, RIS) beyond small demos.

Real-time deployment, mobile apps, or large-scale real-data pipelines.

Full SLAM frameworks or high-performance mapping stacks.

2. Scope & Use Cases
2.1 Scope

The repo implements simulation-first reference versions of:

Coordinate transforms (body/map/ENU/NED/LLH) and attitude representations.

LS/WLS and robust LS; KF/EKF/UKF/PF; basic FGO wrappers.

RF point positioning (TOA / two-way TOA / TDOA / AOA / RSS).

Fingerprinting (Wi-Fi / magnetic / hybrid; deterministic & probabilistic).

Proprioceptive sensor models (IMU, wheel odom, PDR, barometer, magnetometer).

Minimal 2D SLAM & sensor fusion demos (Loosely vs Tightly coupled; observability).

2.2 Typical Use Cases

‚ÄúRun a notebook to reproduce a figure similar to chapter X.‚Äù

‚ÄúSwap KF ‚Üî FGO on the same simulated trajectory.‚Äù

‚ÄúCompare RF trilateration vs TDOA vs AOA in a toy floor.‚Äù

‚ÄúCompare k-NN fingerprinting vs a simple ML model on a synthetic RF map.‚Äù

This section sets what problems the repo must solve, not just what code exists.

3. High-Level Architecture

Repo layout:

ipin-examples/
  core/
    coords/
    estimators/
    rf/
    sensors/
    sim/
    eval/
    fingerprinting/
  ch2_coords/
  ch3_estimators/
  ch4_rf_point_positioning/
  ch5_fingerprinting/
  ch6_dead_reckoning/
  ch7_slam/
  ch8_sensor_fusion/
  data/
    sim/
    real/    # optional, small demo logs only
  notebooks/
  docs/
  tools/
    check_equation_index.py


Directory roles:

core/
Reusable math & models used across chapters (never import from chX_.../):

coords/ ‚Äì frames, LLH‚ÜîECEF‚ÜîENU, ENU‚ÜîNED, attitude conversions.

estimators/ ‚Äì LS/WLS, robust LS, KF/EKF/UKF/PF, FGO wrappers.

rf/ ‚Äì TOA/TDOA/AOA/RSS models, DOP utilities.

sensors/ ‚Äì IMU, wheel odom, PDR, mag, barometer models.

sim/ ‚Äì trajectory generators, scenario definitions, noise injection.

eval/ ‚Äì error metrics, CDFs, NEES/NIS, DOP.

fingerprinting/ ‚Äì deterministic (NN / k-NN) and probabilistic (Bayesian) fingerprinting algorithms reused across Chapter 5 and fusion examples.

chX_.../
Thin chapter-specific examples:

Wiring code & scripts.

Plots and figure reproduction.

Minimal glue code between core/ and data.

data/sim/
Standardized simulation datasets (Section 5).

data/real/
Optional, very small demonstration logs (not the main focus).

notebooks/
One notebook (or small set) per chapter, referencing equations and pointing to core/ modules.

docs/
Markdown docs per chapter + equation_index.yml and usage docs.

tools/
CI/maintenance scripts, especially equation mapping checker.

4. Core Functional Requirements (Basic Functions)

For each core submodule, the design doc specifies:

Purpose

Key data structures

Required functions / classes (with rough signatures)

Equation mapping expectations (docstring conventions, index entries)

Owner: navigation engineer vs software engineer.

4.1 core/coords

Purpose

Implement coordinate and attitude foundations of Ch.2.

Basic functions

Geodetic / ECEF / local frames:

llh_to_ecef(llh) -> np.ndarray

ecef_to_llh(ecef) -> np.ndarray

ecef_to_enu(ecef, ref_llh) -> np.ndarray

enu_to_ecef(enu, ref_llh) -> np.ndarray

enu_to_ned(enu) -> np.ndarray

ned_to_enu(ned) -> np.ndarray

Attitude conversions:

rpy_to_rotmat(roll, pitch, yaw) -> np.ndarray

rotmat_to_rpy(R) -> Tuple[float, float, float]

quat_to_rotmat(q) -> np.ndarray

rotmat_to_quat(R) -> np.ndarray

Equation mapping

All core transforms have docstrings like:

"Implements Eq. (2.x) in Chapter 2: ..."

Each implemented equation appears in docs/equation_index.yml.

Unique tasks

Support multiple map frames (multi-floor, building frames).

Enforce consistent frame naming/metadata used by RF, PDR, SLAM.

4.2 core/estimators
4.2.1 Purpose

This module implements the core estimation and filtering algorithms from Chapter 3 and exposes them through reusable APIs that other modules (core/rf, core/sensors, chX_...) can call.

Goals:

Provide reference implementations of:

Least squares (LS), weighted LS (WLS), and robust LS.

Linear KF, EKF, UKF, PF.

Factor graph optimization (FGO) with basic numerical solvers.

Maintain equation-level traceability to Chapter 3:

Each algorithm implementation references the exact equation numbers it follows.

Reuse the same estimator APIs across RF positioning, PDR, SLAM, and fusion examples.

4.2.2 Key abstractions & data structures

State vector

State = np.ndarray of shape (n,).

Covariance matrix

Covariance = np.ndarray of shape (n, n).

Measurement vector

Measurement = np.ndarray of shape (m,).

ProcessModel (for KF/EKF/UKF/FGO)

Encapsulates system dynamics:

f(x, u, dt) -> x_next: nonlinear state propagation (Eq. (3.21) for EKF, Eq. (3.25) for UKF).

F(x, u, dt) -> Fk: Jacobian ‚àÇf/‚àÇx for EKF (used in Eq. (3.22)).

Q(x, u, dt) -> Qk: process noise covariance.

MeasurementModel

Encapsulates sensor model:

h(x) -> z_pred: linear or nonlinear measurement (e.g. Eq. (3.8) for KF, Eq. (3.21) measurement part).

H(x) -> Hk: Jacobian ‚àÇh/‚àÇx for EKF.

R(x) -> Rk: measurement noise covariance (Œ£_{w,z,k}).

Factor / FactorGraph (for FGO)

Factor:

Holds residual function r(x_subset) and its Jacobian (or automatic differentiation stub).

FactorGraph:

Collection of variables and factors representing the MAP optimization problem of Eq. (3.35)‚Äì(3.38).

All estimators share these abstractions so that changing the estimator does not require changing the sensor or motion models.

4.2.3 Least Squares (LS / WLS / Robust LS)

Relevant equations (Chapter 3)

Cost function:
J(x) = Œ£ (y·µ¢ ‚àí h·µ¢(x))¬≤ ‚Üí Eq. (3.1).

Linear model normal equations:
H·µÄH xÃÇ = H·µÄ y ‚Üí Eq. (3.2).
xÃÇ = (H·µÄH)‚Åª¬π H·µÄ y ‚Üí Eq. (3.3).

Nonlinear LS optimality condition:
Œ£ (y·µ¢ ‚àí h·µ¢(x)) ‚àáh·µ¢(x) = 0 ‚Üí Eq. (3.4).

Weighted LS cost (no explicit equation number, defined in the text in 3.1.1):
J(x) = Œ£ w·µ¢ (y·µ¢ ‚àí h·µ¢(x))¬≤.

Planned API (in core/estimators/least_squares.py)

def linear_least_squares(H: np.ndarray, y: np.ndarray) -> np.ndarray:
Implements Eq. (3.2)‚Äì(3.3).
Docstring must include:
‚ÄúImplements Eqs. (3.2)‚Äì(3.3) (normal equations and closed form LS solution).‚Äù

def weighted_least_squares(H: np.ndarray, y: np.ndarray, W: np.ndarray) -> np.ndarray:
W is diagonal or full weight (inverse covariance).
Generalizes Eq. (3.2)‚Äì(3.3) to WLS.
Docstring: ‚ÄúImplements weighted least squares as defined in Section 3.1.1.‚Äù

def gauss_newton_solve(h_fun, jac_fun, y, x0, max_iters, tol) -> np.ndarray:
Implements iterative solution of Eq. (3.4): residual gradient = 0 via Gauss‚ÄìNewton.
Used for nonlinear LS in RF / SLAM.

def robust_least_squares(...) -> np.ndarray:
Wraps LS with robust loss functions (Huber, Cauchy, etc.) as described in Section 3.1.1.
Docstring references Table 3.1 + robust LS text, even if no explicit equation number.

Equation mapping requirements

linear_least_squares docstring: references Eqs. (3.2)‚Äì(3.3).

gauss_newton_solve: references Eq. (3.4).

equation_index.yml must map:

"Eq. (3.2)" and "Eq. (3.3)" ‚Üí core/estimators/least_squares.py::linear_least_squares.

"Eq. (3.4)" ‚Üí core/estimators/least_squares.py::gauss_newton_solve.

4.2.4 Kalman Filter Family (KF / EKF / UKF)

(a) Linear Kalman Filter

Relevant equations (Chapter 3)

Linear measurement model:
z_k = H_k x_k + w_{z,k} ‚Üí Eq. (3.8).

Likelihood mean/covariance:
E[z_k | x_k] = H_k x_k, Cov[z_k | x_k] = Œ£_{w,z,k} ‚Üí Eq. (3.9).

Propagation model and prior mean/cov:
x‚Çñ,‚Çñ‚Çã‚ÇÅ = F_k x_{k‚àí1} + u_k + w_{x,k‚àí1} ‚Üí Eq. (3.11).
P_{k,k‚àí1} = F_k Œ£_{x,k‚àí1} F_k·µÄ + Œ£_{w,u,k} ‚Üí Eq. (3.12).

MAP derivation and posterior:
Posterior density (3.13), MAP via derivative (3.15), closed form (3.16).

KF update form:
xÃÇ_{k,MAP} = x_{k,k‚àí1} + K_k (z_k ‚àí H_k x_{k,k‚àí1}) ‚Üí Eq. (3.17).
K_k = P_{k,k‚àí1} H_k·µÄ (H_k P_{k,k‚àí1} H_k·µÄ + Œ£_{w,z,k})‚Åª¬π ‚Üí Eq. (3.18).
Covariance: Œ£_{x,k} = P_{k,k‚àí1} ‚àí F_k K_k H_k P_{k,k‚àí1} ‚Üí Eq. (3.19).
Summary of ‚Äúfive equations‚Äù ‚Üí grouped as Eq. (3.20).

Planned API (in core/estimators/kalman.py)

class KalmanFilter:
__init__(self, F, Q, H, R) ‚Äì constant matrices or callables.
predict(self, u: np.ndarray = None)

Implements propagation from Eqs. (3.11), (3.12) and the first two lines of (3.20).
update(self, z: np.ndarray)

Implements Eqs. (3.17)‚Äì(3.19) and full set in (3.20).

Equation mapping requirements

predict docstring: ‚ÄúImplements the prediction step of the linear Kalman filter (Eqs. (3.11), (3.12), (3.20)).‚Äù

update docstring: ‚ÄúImplements the update step (Eqs. (3.17)‚Äì(3.20)).‚Äù

equation_index.yml:

"Eq. (3.11)", "Eq. (3.12)", "Eq. (3.17)", "Eq. (3.18)", "Eq. (3.19)", "Eq. (3.20)" ‚Üí KalmanFilter.predict / KalmanFilter.update.

(b) Extended Kalman Filter (EKF)

Relevant equations (Chapter 3)

Nonlinear state & measurement model:
x_k = f(x_{k‚àí1}, u_k) + w_k, z_k = h(x_k) + v_k ‚Üí Eq. (3.21).

EKF prediction:
xÃÇ_k‚Åª = f(xÃÇ_{k‚àí1}, u_k),
P_k‚Åª = F_{k‚àí1} P_{k‚àí1} F_{k‚àí1}·µÄ + Q ‚Üí Eq. (3.22).

EKF update (on the next page, same section; equation number continues, but we primarily tie to Eq. (3.21)‚Äì(3.23)).

Planned API

class ExtendedKalmanFilter(KalmanFilter):
Accepts ProcessModel and MeasurementModel objects instead of fixed matrices.
predict(self, u, dt):

Uses f, F, and Q ‚Üí Eq. (3.21) and (3.22).
update(self, z):

Uses h, H, R and standard KF structure, referencing EKF update equations in the EKF subsection.

Equation mapping

predict docstring: ‚ÄúImplements EKF prediction (Eqs. (3.21)‚Äì(3.22)).‚Äù

update docstring: ‚ÄúImplements EKF update (EKF section following Eq. (3.21)).‚Äù

equation_index.yml: map "Eq. (3.21)", "Eq. (3.22)" to ExtendedKalmanFilter.predict.

(c) Unscented Kalman Filter (UKF)

Relevant equations (Chapter 3)

Sigma point generation:
œá‚ÇÄ = xÃÇ_{k‚àí1}, œá·µ¢ = xÃÇ_{k‚àí1} + Œ¥·µ¢, œá_{i+n} = xÃÇ_{k‚àí1} ‚àí Œ¥·µ¢, i=1..n ‚Üí Eq. (3.24).

Sigma point propagation through f (process) and h (measurement):
œá·µ¢‚Åª = f(œá·µ¢, u_k) ‚Üí Eq. (3.25).

UKF update and gain:
K_k, xÃÇ_k, P_k defined via cross covariances and measurement covariances ‚Üí Eq. (3.30).

Planned API

class UnscentedKalmanFilter:
__init__(self, process_model, measurement_model, alpha, beta, kappa)
predict(self, u, dt)

Generates sigma points (Eq. (3.24)), propagates via f (Eq. (3.25)), computes predicted mean/cov.
update(self, z)

Computes predicted measurement, cross covariance, Kalman gain, and posterior state following Eq. (3.30).

Equation mapping

Docstrings reference Eqs. (3.24), (3.25), (3.30) explicitly.

equation_index.yml maps these equations to the UKF methods.

4.2.5 Particle Filter (PF)

Relevant equations (Chapter 3)

Recursive Bayes update:
p(x_k | z‚ÇÅ:k) ‚àù p(z_k | x_k) p(x_k | z‚ÇÅ:k‚àí1) ‚Üí Eq. (3.32).

Sampling step:
x_k‚ÅΩ‚Å±‚Åæ ‚àº p(x_k | x_{k‚àí1}‚ÅΩ‚Å±‚Åæ) ‚Üí Eq. (3.33).

Weight update:
·∫á_k‚ÅΩ‚Å±‚Åæ = w_{k‚àí1}‚ÅΩ‚Å±‚Åæ p(z_k | x_k‚ÅΩ‚Å±‚Åæ) ‚Üí Eq. (3.34).

Planned API (in core/estimators/particle.py)

class ParticleFilter:
Attributes: particles (N√ón), weights (N,), process_model, measurement_model.
predict(self, u, dt):

Sample new particles using the process model (Eq. (3.33)).
update(self, z):

Update weights via likelihood (Eq. (3.34)), normalize, resample.
estimate(self) -> np.ndarray:

Return weighted mean or best weight particle.

Equation mapping

predict docstring references Eq. (3.33).

update docstring references Eqs. (3.32)‚Äì(3.34).

equation_index.yml: "Eq. (3.32)", "Eq. (3.33)", "Eq. (3.34)" ‚Üí ParticleFilter.

4.2.6 Factor Graph Optimization (FGO) & Numerical Methods

Relevant equations (Chapter 3)

MAP for full trajectory:
XÃÇ_{MAP} = argmax_X p(X | Z) = argmax_X p(Z | X) p(X) / p(Z) ‚Üí Eq. (3.35).

Simplified MAP form:
XÃÇ_{MAP} = argmax_X ‚Ñì(X; Z) p(X) with ‚Ñì(X; Z) ‚àù p(Z | X) ‚Üí Eqs. (3.36)‚Äì(3.37).

Conversion from product of Gaussians to sum of squared residuals (negative log posterior) ‚Üí Eq. (3.38) and following.

Gradient descent update:
x_{k+1} = x_k + Œ± d ‚Üí Eq. (3.42).

Descent condition:
f(x_{k+1}) = f(x_k + Œ± d) < f(x_k) ‚Üí Eq. (3.43).

Planned API (in core/estimators/fgo.py and core/estimators/optim.py)

class Factor:
def residual(self, x: np.ndarray) -> np.ndarray:
def jacobian(self, x: np.ndarray) -> np.ndarray:

class FactorGraph:
Stores variable ordering, list of factors.
def evaluate(self, x: np.ndarray) -> Tuple[r, J]: returns stacked residuals and Jacobian.

def gradient_descent_step(x, grad, alpha) -> np.ndarray:
Encodes Eq. (3.42) and Eq. (3.43) logic.

def gauss_newton_step(x, J, r) -> np.ndarray:
Equivalent to LS step on residuals derived from Eq. (3.38).

def levenberg_marquardt_step(...) -> np.ndarray:
LM step bridging gradient descent and Gauss‚ÄìNewton, consistent with 3.4.1 discussion.

def solve_fgo(graph: FactorGraph, x0, method='gn', max_iters=..., tol=...) -> np.ndarray:
High-level solver that iteratively applies GN/LM using the factor graph.

Equation mapping

solve_fgo docstring references Eqs. (3.35)‚Äì(3.38) (MAP via factor graph).

gradient_descent_step docstring references Eqs. (3.42)‚Äì(3.43).

equation_index.yml ties these equations to the corresponding functions.

4.2.7 Simulation data requirements (for estimators)

Although most estimators are exercised through chapter specific scenarios, core/estimators also needs simple synthetic datasets for unit tests and minimal examples:

toy_ls_linear/
Small linear regression / linear system:

H (m√ón), y (m), known true x_true, noise variance.
Used to test:

linear_least_squares, weighted_least_squares, robust_least_squares.
Must be documented in Section 5.2 as one of the dataset families.

toy_kf_1d_cv/
1D constant velocity (CV) model:

State: [position, velocity].

Measurements: noisy position only.
Used to test:

KalmanFilter convergence vs. analytical solution.

toy_nonlinear_1d/
1D or 2D nonlinear tracking:

Nonlinear measurement, e.g. range¬≤, to exercise EKF, UKF, PF, and FGO.
Used to:

Compare KF vs. EKF vs. UKF vs. PF on the same synthetic data.

Test FGO smoothing vs. recursive filters.

These datasets should be stored under data/sim/ (see Section 5.2) and used both by:

Unit tests in tests/test_estimators_*.py.

A small ch3_estimators notebook that reproduces selected plots / behaviors from Chapter 3.

4.3 core/rf

Purpose

RF signal measurement models from Ch.4‚Äì5.

Basic functions

Ranging / angles:

toa_range(tx_pos, rx_pos, c, clock_bias)

two_way_toa_range(...)

tdoa_range_diff(anchor_i, anchor_j, state, c)

aoa_bearing(anchor_pos, state)

RSS:

rss_pathloss(tx_power, distance, n, sigma_shadow)

DOP:

compute_dop(geometry, weights=None) -> dict with HDOP/VDOP/PDOP.

Equation mapping

Each measurement model documents which equations in Ch.4 it implements (e.g. path-loss, hyperbolic TDOA, AOA geometry).

Unique tasks

Support multiple technologies (Wi-Fi, BLE, UWB, 5G) through parameterization rather than separate code.

4.4 core/sensors

Purpose

Proprioceptive & environmental sensor models from Ch.6.

Basic functions

IMU:

Continuous/discrete error models (bias, noise, RW).

Simple strapdown integration for 2D/3D.

PDR:

Step detection, step length models, heading from IMU/mag.

Environmental:

Barometer altitude, floor detection.

Magnetometer heading and magnetic fingerprint stubs.

Wheel odometry:

Differential drive, steering model, noise models.

Equation mapping

IMU propagation, error models, ZUPT updates etc. point to Ch.6 equations.

Unique tasks

Define a unified sensor packet structure used across simulation and logs.

4.4.1 Chapter 6 scope and design stance

This module implements the proprioceptive + environmental sensor models and dead-reckoning algorithms from Chapter 6:

IMU strapdown propagation (attitude/velocity/position).

Wheel odometry dead reckoning (vehicle).

Integrated IMU + wheel speed fusion (EKF).

Drift correction constraints: ZUPT / ZARU / NHC.

Pedestrian Dead Reckoning (PDR): step detection + step length + heading + step update.

Environmental sensors: magnetometer heading, barometer altitude / floor change.

Calibration utilities: Allan variance; IMU scale/misalignment model.

Design stance

Dead-reckoning drifts. Examples must make drift clearly visible, then show how constraints/fusion reduce it.

Keep two tracks for teaching clarity:

Pure propagation (strapdown / PDR) to show drift.

Constraint/fusion (EKF updates with ZUPT/ZARU/NHC, mag/baro) to show drift reduction.

Avoid production-grade INS complexity unless needed. Implement the chapter equations faithfully, with minimal state choices.

4.4.2 Key data structures and packet formats

All structures live in core/sensors/types.py.

Time base

Use float seconds t (monotonic), or timestamp arrays np.ndarray (preferred).

Sensor series packets

from dataclasses import dataclass
import numpy as np

@dataclass(frozen=True)
class ImuSeries:
    t: np.ndarray        # (N,)
    accel: np.ndarray    # (N,3) m/s^2 in body frame B
    gyro: np.ndarray     # (N,3) rad/s in body frame B
    meta: dict

@dataclass(frozen=True)
class WheelSpeedSeries:
    t: np.ndarray        # (N,)
    v_s: np.ndarray      # (N,3) velocity in speed frame S (per Chapter 6)
    meta: dict

@dataclass(frozen=True)
class MagnetometerSeries:
    t: np.ndarray
    mag: np.ndarray      # (N,3) in device/body frame
    meta: dict

@dataclass(frozen=True)
class BarometerSeries:
    t: np.ndarray
    pressure: np.ndarray # (N,) Pa (or hPa, but must be explicit in meta)
    meta: dict


Navigation state (minimal Chapter-6 state)

Base state is consistent with Chapter-6 integrated formulation (quaternion + velocity + position), e.g. Eq. (6.16).

@dataclass
class NavStateQPVP:
    q: np.ndarray  # (4,) quaternion scalar-first (q0,q1,q2,q3)
    v: np.ndarray  # (3,) velocity in map frame M
    p: np.ndarray  # (3,) position in map frame M


Bias-augmented state (recommended for realism)

Add gyro and accel biases when implementing Eq. (6.5)/(6.9) style models.

@dataclass
class NavStateQPVPBias:
    q: np.ndarray      # (4,)
    v: np.ndarray      # (3,)
    p: np.ndarray      # (3,)
    b_g: np.ndarray    # (3,) gyro bias
    b_a: np.ndarray    # (3,) accel bias


Rule

Chapter-6 examples may start with NavStateQPVP to keep concepts simple, then optionally switch to NavStateQPVPBias in ‚Äúadvanced‚Äù notebooks/tests.

4.4.3 Module layout

Recommended layout:

core/sensors/
  types.py
  imu_models.py          # measurement correction + calibration helpers
  strapdown.py           # quaternion/vel/pos propagation
  wheel_odometry.py      # wheel speed DR + lever-arm compensation
  ins_ekf_models.py      # ProcessModel/MeasurementModel for IMU+wheel EKF
  constraints.py         # ZUPT / ZARU / NHC detectors + pseudo-measurements
  pdr.py                 # step detection, step length, PDR propagation
  environment.py         # mag heading + baro altitude (+ small smoothing helper)
  calibration.py         # Allan variance + IMU scale/misalignment model

4.4.4 IMU strapdown propagation APIs (Chapter 6 quaternion/velocity/position)

Quaternion propagation (Eqs. (6.2)‚Äì(6.4), Œ© matrix Eq. (6.3))

def omega_matrix(omega_b: np.ndarray) -> np.ndarray:
    """
    Build Œ©(œâ) used in quaternion kinematics.
    Implements Eq. (6.3).
    """

def quat_integrate(q_prev: np.ndarray, omega_b: np.ndarray, dt: float) -> np.ndarray:
    """
    Discrete quaternion update.
    Implements Eqs. (6.2)‚Äì(6.4).
    Note: normalize output quaternion each step.
    """


IMU correction (gyro/accel bias/noise; Eqs. (6.5)‚Äì(6.6), Eq. (6.9))

def correct_gyro(gyro_meas: np.ndarray, b_g: np.ndarray, n_g: np.ndarray | None = None) -> np.ndarray:
    """
    œâ = œâ~ - b_g - n_g.
    Implements Eq. (6.6) (consistent with Eq. (6.5)).
    """

def correct_accel(accel_meas: np.ndarray, b_a: np.ndarray, n_a: np.ndarray | None = None) -> np.ndarray:
    """
    Specific force correction consistent with Eq. (6.9).
    """


Velocity, gravity, position updates (Eqs. (6.7)‚Äì(6.10))

def gravity_vector() -> np.ndarray:
    """
    Gravity approximation.
    Implements Eq. (6.8).
    """

def vel_update(v_prev: np.ndarray, q_prev: np.ndarray, f_b: np.ndarray, dt: float) -> np.ndarray:
    """
    v_k = v_{k-1} + (C_B^M(q) f_b + g) dt.
    Implements Eq. (6.7).
    """

def pos_update(p_prev: np.ndarray, v_prev: np.ndarray, dt: float) -> np.ndarray:
    """
    p_k = p_{k-1} + v_k dt.
    Implements Eq. (6.10).
    """


Note on coordinate transforms

If core/coords/quat_to_rotmat is used for Chapter-6 propagation, add Chapter-6 equation references (e.g. Eq. (6.13) if the book defines the quaternion rotation matrix there) to its docstring in addition to Chapter-2 references.

4.4.5 Wheel odometry dead reckoning APIs (Eqs. (6.11)‚Äì(6.15))

Skew matrix / lever arm / velocity transform / position update:

def skew(v: np.ndarray) -> np.ndarray:
    """
    Skew-symmetric matrix [v√ó].
    Implements Eq. (6.12).
    """

def wheel_speed_to_attitude_velocity(v_s: np.ndarray, omega_b: np.ndarray, lever_arm_b: np.ndarray) -> np.ndarray:
    """
    Convert wheel speed measurement to attitude-frame velocity with lever arm compensation.
    Implements Eq. (6.11).
    """

def attitude_to_map_velocity(v_a: np.ndarray, q: np.ndarray) -> np.ndarray:
    """
    v^M = C_A^M(q) v^A.
    Implements Eq. (6.14).
    """

def odom_pos_update(p_prev: np.ndarray, v_map: np.ndarray, dt: float) -> np.ndarray:
    """
    p_k^M = p_{k-1}^M + v_k^M Œît.
    Implements Eq. (6.15).
    """

4.4.6 Integrated IMU + wheel EKF models (Eqs. (6.16)‚Äì(6.43))

Implement as ProcessModel and MeasurementModel so it plugs into core/estimators/ExtendedKalmanFilter.

Process model (Eqs. (6.17)‚Äì(6.32); state Eq. (6.16))

class InsWheelProcessModel(ProcessModel):
    """
    EKF process model for state x=[q, v, p] (Eq. (6.16)),
    with propagation and covariance per Eqs. (6.17)‚Äì(6.32).
    """

    def f(self, x: np.ndarray, u: dict, dt: float) -> np.ndarray:
        """
        Implements Eq. (6.17) and the concrete sub-updates in the Chapter 6 text.
        """

    def F(self, x: np.ndarray, u: dict, dt: float) -> np.ndarray:
        """
        State Jacobian.
        Implements Eq. (6.28) (and uses Eq. (6.29) where needed).
        """

    def Q(self, x: np.ndarray, u: dict, dt: float) -> np.ndarray:
        """
        Process noise covariance.
        Implements Eqs. (6.30)‚Äì(6.31).
        """


Wheel measurement model (Eqs. (6.33)‚Äì(6.38))

class WheelSpeedMeasurementModel(MeasurementModel):
    """
    Wheel-speed measurement model.
    Implements Eqs. (6.33)‚Äì(6.38).
    """

    def h(self, x: np.ndarray) -> np.ndarray:
        """Implements Eqs. (6.33)‚Äì(6.35)."""

    def H(self, x: np.ndarray) -> np.ndarray:
        """Implements Eqs. (6.37)‚Äì(6.38)."""

    def R(self, x: np.ndarray) -> np.ndarray:
        """Measurement covariance (configurable)."""


EKF update equations (Eqs. (6.39)‚Äì(6.43))

Do not duplicate EKF update logic in core/sensors.

core/estimators/ExtendedKalmanFilter.update() is the single source of truth.

Add docstring references in ExtendedKalmanFilter.update() to include both:

Chapter 3 EKF update block, and

Chapter 6 EKF update block (Eqs. (6.39)‚Äì(6.43)).

4.4.7 Drift correction constraints (ZUPT / ZARU / NHC)

ZUPT detector (Eq. (6.44)) and pseudo-measurement (Eq. (6.45))

def detect_zupt(gyro_b: np.ndarray, accel_b: np.ndarray, delta_omega: float, delta_f: float) -> bool:
    """
    Stationary detector.
    Implements Eq. (6.44).
    """

class ZuptMeasurementModel(MeasurementModel):
    """
    Zero-velocity pseudo-measurement.
    Implements Eq. (6.45).
    """


ZARU pseudo-measurement (Eq. (6.60))

class ZaruMeasurementModel(MeasurementModel):
    """
    Zero angular rate pseudo-measurement.
    Implements Eq. (6.60).
    """


NHC pseudo-measurement (Eq. (6.61))

class NhcMeasurementModel(MeasurementModel):
    """
    Nonholonomic constraint pseudo-measurement.
    Implements Eq. (6.61).
    """


Practical warning (must be shown in examples)

These constraints are only valid under their motion assumptions.

Include at least one ‚Äúassumption violated‚Äù segment (e.g., wheel slip, foot sliding) and show the failure mode.

4.4.8 PDR APIs (Eqs. (6.46)‚Äì(6.50))
def total_accel_magnitude(accel_b: np.ndarray) -> float:
    """Implements Eq. (6.46)."""

def remove_gravity_from_magnitude(a_mag: float, g: float = 9.81) -> float:
    """Implements Eq. (6.47)."""

def step_frequency(delta_t: float) -> float:
    """Implements Eq. (6.48)."""

def step_length(h: float, f_step: float, a: float = 0.371, b: float = 0.227, c: float = 1.0) -> float:
    """Implements Eq. (6.49)."""

def pdr_step_update(p_prev_xy: np.ndarray, step_len: float, heading_rad: float) -> np.ndarray:
    """
    2D PDR step update.
    Implements Eq. (6.50) specialized to 2D.
    """


Heading sources for PDR examples

Gyro-integrated yaw (drifts).

Magnetometer heading (suffers indoor disturbance).

Optional smoothing filter using Eq. (6.55) style model.

4.4.9 Environmental sensor models (magnetometer + barometer) (Eqs. (6.51)‚Äì(6.55))

Magnetometer heading (Eqs. (6.51)‚Äì(6.53))

def mag_tilt_compensate(mag_b: np.ndarray, roll: float, pitch: float) -> np.ndarray:
    """Implements Eq. (6.52)."""

def mag_heading(mag_b: np.ndarray, roll: float, pitch: float) -> float:
    """Implements Eqs. (6.51)‚Äì(6.53)."""


Barometer altitude (Eq. (6.54))

def pressure_to_altitude(p: float, p0: float, T: float) -> float:
    """Implements Eq. (6.54)."""


Optional smoothing helper (Eq. (6.55))

Provide a small reusable ‚Äúaltitude smoothing KF‚Äù or ‚Äúheading smoothing KF‚Äù helper that references Eq. (6.55) as the generic state/measurement model, but still uses core/estimators KF/EKF APIs.

4.4.10 Calibration utilities (Eqs. (6.56)‚Äì(6.59))

Allan variance (Eqs. (6.56)‚Äì(6.58))

def allan_variance(x: np.ndarray, fs: float, taus: np.ndarray) -> np.ndarray:
    """Implements Eqs. (6.56)‚Äì(6.58)."""


IMU scale/misalignment model (Eq. (6.59))

def apply_imu_scale_misalignment(u: np.ndarray, M: np.ndarray, S: np.ndarray, b: np.ndarray) -> np.ndarray:
    """Implements Eq. (6.59)."""

4.4.11 Simulation data requirements (for sensors / Chapter 6)

Although most Chapter-6 algorithms are exercised through ch6_dead_reckoning, core/sensors must be testable with standardized simulation datasets stored in data/sim/ (see Section 5.2):

ch6_strapdown_basic/

ch6_wheel_odom_square/

ch6_foot_zupt_walk/

ch6_pdr_corridor_walk/

ch6_env_sensors_heading_altitude/

These datasets must be deterministic (fixed seeds, config files), small, and documented.

2) INSERT into Section 5.2 Dataset Families (no deletion required)

In Section 5.2 Dataset Families, after your existing pdr_corridor_walk/ entry (or right after wifi_fingerprint_grid/ if you prefer), insert the following additional dataset families:

ch6_strapdown_basic/
Baseline strapdown IMU propagation dataset (attitude/velocity/position).

Files (NPZ preferred):
truth.npz: t, q, v, p
imu.npz: t, accel, gyro (optional b_g_true, b_a_true)
config.json: dt, noise, bias, initial conditions, frame definitions

ch6_wheel_odom_square/
Vehicle-style dataset for wheel DR and IMU+wheel EKF.

Files:
truth.npz: t, q, v, p
wheel.npz: t, v_s (speed frame S)
imu.npz: t, accel, gyro
config.json: lever arm, wheel noise, optional slip segments

ch6_foot_zupt_walk/
Foot-mounted INS dataset with stance phases for ZUPT/ZARU.

Files:
truth.npz: t, q, v, p
imu.npz
events.npz: stance_mask (optional for evaluation)
config.json: detector thresholds (Œ¥_œâ, Œ¥_f), sample rate

ch6_pdr_corridor_walk/
Step-and-heading PDR dataset (lightweight PDR baseline).

Files:
truth_xy.npz: t, p_xy, heading_true
imu.npz
config.json: user height h, (a,b,c) parameters for step length model

ch6_env_sensors_heading_altitude/
Environmental sensor dataset (mag heading + barometer altitude).

Files:
truth.npz: heading_true, altitude_true
mag.npz, baro.npz
config.json: disturbance segments, p0 and T for barometer model

4.5 core/sim

Purpose

Shared simulation tools for all examples.

Basic functions

Trajectories:

generate_2d_trajectory(shape, params, dt, duration)

generate_3d_trajectory(...)

Scenarios:

Rooms/floor plans, beacons/anchors, obstacles.

Sensor noise injection:

add_imu_noise(traj, model_params)

simulate_rf_measurements(traj, anchors, rf_config)

Unique tasks

Scenario configurations in JSON/YAML so all chapters share the same definitions.

4.6 core/eval

Purpose

Evaluation and visualization utilities shared across chapters.

Provide a small, consistent API for:

computing errors and consistency metrics, and

generating publication-quality, vector graphics for trajectories, errors, and algorithm comparisons.

Basic functions (numerical evaluation)

Position errors:

compute_position_errors(truth, est) -> dict
Per-epoch error vectors (ENU / NED).

compute_rmse(errors) -> float | dict
Scalar RMSE or per-axis RMSE.

compute_error_stats(errors) -> dict
mean / median / percentiles.

Consistency metrics:

compute_nees(truth, est, cov) -> np.ndarray

compute_nis(innov, S) -> np.ndarray

helpers to check NEES/NIS against œá¬≤ bounds.

RF / geometry utilities:

compute_dop(geometry, weights=None) -> dict (HDOP/VDOP/PDOP), reusing core/coords for frame handling.

574882d9-b20d-4e2c-a4e3-c94a8d9‚Ä¶

Basic functions (visualization)

All plotting helpers live in core/eval/plots.py. They must:

accept plain NumPy arrays / dicts (no hidden global state), and

return a matplotlib.figure.Figure (the caller decides whether to show or save).

Planned APIs:

Trajectory / map views

plot_trajectory_2d(truth_xy, est_xy_dict, anchors_xy=None) -> Figure
truth vs. one or more estimates on a 2D floor plan.
optional RF anchors / landmarks overlay.

plot_trajectory_3d(truth_xyz, est_xyz_dict, anchors_xyz=None) -> Figure
simple 3D view for SLAM / multi-floor examples.

Error over time

plot_position_error_time(errors_dict, dt, axes="enu") -> Figure
per-axis error vs. time, multiple algorithms on one plot.

Error distributions

plot_error_hist(errors_dict, bins=‚Ä¶) -> Figure

plot_error_cdf(errors_dict) -> Figure
used heavily in Ch.4‚Äì5 to compare RF / fingerprinting methods.

574882d9-b20d-4e2c-a4e3-c94a8d9‚Ä¶

Consistency plots

plot_nees(nees, chi2_bounds) -> Figure

plot_nis(nis, chi2_bounds) -> Figure

RF geometry / DOP

plot_rf_geometry(anchors_xy, traj_xy=None) -> Figure

plot_dop_map(dop_grid, floorplan=None) -> Figure
visualize how beacon layouts (or AP layouts) affect HDOP / VDOP.

SLAM / map views (minimal)

plot_occupancy_grid(grid, poses=None, landmarks=None) -> Figure

plot_factor_graph_skeleton(nodes, edges) -> Figure (optional, diagnostic only).

Standard vector export

To make results easy to reuse in papers and slides, every plotting helper must work with a single, shared export utility:

save_figure(fig, out_dir, name, formats=("svg", "pdf")) -> list[path]

ensures:

vector formats by default (.svg, .pdf),

deterministic naming, and

creation of the output directory if needed.

File and naming conventions

All chapter examples should save figures into:

chX_.../figs/ for scripts, or

notebooks/figs/chX_.../ for notebooks.

File names must follow:

ch3_estimators_kf_vs_pf_rmse.svg

ch4_rf_toa_vs_tdoa_cdf.pdf

ch6_pdr_drift_correction_trajectory.svg

Notebooks embed the figure inline, but also call save_figure so users get reusable vector files with a single run.

Visual style guidelines

To keep plots visually consistent across the repo:

Always label axes with units, e.g. Position error [m], Time [s], Heading [deg].

Use the same color / linestyle mapping for estimator families across chapters:

LS/WLS: solid blue

KF/EKF/UKF: solid green

PF: dashed orange

FGO / smoothing: solid red

Keep backgrounds white and gridlines light (MATLAB/Matplotlib default is fine).

Avoid heavy custom styling in core; chapter examples can adjust if needed.

Unique tasks

Define a small set of ‚Äústandard plots‚Äù per chapter (see Section 7) and implement them using core/eval/plots.py.

Make sure every example script / notebook:

prints a small numerical summary (RMSE, final bias, etc.), and

generates at least one vector figure via save_figure(...).

Ensure that evaluation APIs are reused across RF, PDR, SLAM, and fusion examples so that algorithm comparisons are meaningful and visually comparable.

4.7 core/fingerprinting
4.7.1 Purpose

This module collects the generic fingerprinting algorithms from Chapter 5 into reusable code:

Deterministic fingerprinting (NN, k-NN).

Probabilistic fingerprinting (Bayesian / Naive Bayes style).

Optional model-based utilities to support ray-tracing / position-hypothesized methods.

Goals:

Provide clean, reusable APIs for fingerprint-based localization.

Maintain equation-level traceability to Chapter 5:

Each algorithm implementation references the relevant Eq. (5.x).

Allow chapter examples (ch5_fingerprinting/, ch8_sensor_fusion/) to reuse the same algorithms.

4.7.2 Key data structures

All defined in core/fingerprinting/dataset.py and core/fingerprinting/types.py.

Location vector

Location = np.ndarray of shape (d,) (typically d = 2 or 3).

Fingerprint / feature vector

Fingerprint = np.ndarray of shape (N,), where N is number of features (e.g. RSSI from N APs).

FingerprintDatabase

@dataclass
class FingerprintDatabase:
    locations: np.ndarray  # shape (M, d), x_i
    features: np.ndarray   # shape (M, N), f_i
    meta: dict             # AP IDs, floor labels, etc.


Query fingerprint

z: np.ndarray of shape (N,), same dimension and ordering as database f_i.

Equation mapping rule:

Any algorithm that directly implements an equation from Chapter 5 must:

Include that equation ID in its docstring (e.g. ‚ÄúImplements Eq. (5.1)‚Äù).

Have a corresponding entry in docs/equation_index.yml.

4.7.3 Deterministic fingerprinting (NN / k-NN)

Relevant equations (Chapter 5):

Nearest neighbor (1-NN): decision rule based on distance

ùëñ
‚àó
=
arg
‚Å°
min
‚Å°
ùëñ
ùê∑
(
ùëß
,
ùëì
ùëñ
)
i
‚àó
=argmin
i
	‚Äã

D(z,f
i
	‚Äã

) (Eq. (5.1)).

Weighted k-NN interpolation:

ùë•
^
=
‚àë
ùëñ
‚àà
ùêæ
(
ùëß
)
ùë§
ùëñ
ùë•
ùëñ
‚àë
ùëñ
‚àà
ùêæ
(
ùëß
)
ùë§
ùëñ
x
^
=
‚àë
i‚ààK(z)
	‚Äã

w
i
	‚Äã

‚àë
i‚ààK(z)
	‚Äã

w
i
	‚Äã

x
i
	‚Äã

	‚Äã

 (Eq. (5.2)),
with typical choice 
ùë§
ùëñ
=
1
/
(
ùê∑
(
ùëß
,
ùëì
ùëñ
)
+
ùúÄ
)
w
i
	‚Äã

=1/(D(z,f
i
	‚Äã

)+Œµ).

Planned API (in core/fingerprinting/deterministic.py):

Distance utilities:

def distance(z: np.ndarray, f: np.ndarray, metric: str = "euclidean") -> float:
    """
    Compute D(z, f) between query fingerprint z and reference fingerprint f.

    Implements the distance metric D(¬∑, ¬∑) used in Eq. (5.1) and Eq. (5.2)
    in Chapter 5 (e.g., Euclidean and Manhattan distances).
    """

def pairwise_distances(
    z: np.ndarray, F: np.ndarray, metric: str = "euclidean"
) -> np.ndarray:
    """
    Compute distances D(z, f_i) for all fingerprints f_i in F.

    Implements the distance evaluation required in Eq. (5.1) across
    all i = 1, ..., M.
    """


Nearest-neighbor localizer (Eq. (5.1)):

def nn_localize(
    z: np.ndarray,
    db: FingerprintDatabase,
    metric: str = "euclidean"
) -> np.ndarray:
    """
    Nearest-neighbor deterministic fingerprinting.

    Implements Eq. (5.1) in Chapter 5:
        i* = argmin_{1<=i<=M} D(z, f_i),
    and returns x_hat = x_{i*}.
    """


k-NN localizer (Eq. (5.2)):

def knn_localize(
    z: np.ndarray,
    db: FingerprintDatabase,
    k: int = 3,
    metric: str = "euclidean",
    weighting: str = "inverse_distance",
    eps: float = 1e-6,
) -> np.ndarray:
    """
    k-nearest-neighbor fingerprinting with interpolation.

    Implements Eq. (5.2) in Chapter 5:
        x_hat = sum_{i in K(z)} w_i x_i / sum_{i in K(z)} w_i,

    with weights w_i defined from D(z, f_i), typically
        w_i = 1 / (D(z, f_i) + eps).
    """


Equation mapping:

nn_localize docstring references Eq. (5.1).

knn_localize docstring references Eq. (5.2).

equation_index.yml entries:

"Eq. (5.1)" ‚Üí core/fingerprinting/deterministic.py::nn_localize.

"Eq. (5.2)" ‚Üí core/fingerprinting/deterministic.py::knn_localize.

4.7.4 Probabilistic fingerprinting (Bayesian)

Relevant equations (Chapter 5):

Posterior over locations:

ùëÉ
(
ùë•
ùëñ
‚à£
ùëç
ùëñ
=
ùëß
)
=
ùëÉ
(
ùëç
ùëñ
=
ùëß
‚à£
ùë•
ùëñ
)
ùëÉ
(
ùë•
ùëñ
)
ùëÉ
(
ùëç
ùëñ
=
ùëß
)
P(x
i
	‚Äã

‚à£Z
i
	‚Äã

=z)=
P(Z
i
	‚Äã

=z)
P(Z
i
	‚Äã

=z‚à£x
i
	‚Äã

)P(x
i
	‚Äã

)
	‚Äã

 (Eq. (5.3)).

ML / MAP estimate:

ùëñ
‚àó
=
arg
‚Å°
max
‚Å°
ùëñ
ùëÉ
(
ùëç
ùëñ
=
ùëß
‚à£
ùë•
ùëñ
)
i
‚àó
=argmax
i
	‚Äã

P(Z
i
	‚Äã

=z‚à£x
i
	‚Äã

) (Eq. (5.4)).

Posterior-mean estimate:

ùë•
^
=
‚àë
ùëñ
=
1
ùëÄ
ùëÉ
(
ùë•
ùëñ
‚à£
ùëç
ùëñ
=
ùëß
)
ùë•
ùëñ
x
^
=‚àë
i=1
M
	‚Äã

P(x
i
	‚Äã

‚à£Z
i
	‚Äã

=z)x
i
	‚Äã

 (Eq. (5.5)).

Planned API (in core/fingerprinting/probabilistic.py):

Model:

@dataclass
class NaiveBayesFingerprintModel:
    """
    Probabilistic fingerprinting model P(z | x_i) under naive Bayes assumptions.

    Implements the Bayesian formulation in Eqs. (5.3)‚Äì(5.5) of Chapter 5:
        - Eq. (5.3): posterior P(x_i | Z_i = z)
        - Eq. (5.4): ML/MAP selection of i*
        - Eq. (5.5): posterior-mean location estimate x_hat
    """
    db: FingerprintDatabase
    priors: np.ndarray  # shape (M,), P(x_i)
    means: np.ndarray   # shape (M, N)
    vars: np.ndarray    # shape (M, N)


Fitting:

def fit_gaussian_naive_bayes(
    db: FingerprintDatabase,
    samples_per_rp: np.ndarray,
    var_floor: float = 1e-4,
    prior: str = "uniform",
) -> NaiveBayesFingerprintModel:
    """
    Fit a Gaussian naive Bayes P(z | x_i) model from offline survey data.

    Each reference point i has empirical mean and variance of each feature,
    which parameterize P(Z_i = z | x_i) in Eq. (5.3).
    """


Inference helpers:

def log_likelihoods(
    model: NaiveBayesFingerprintModel,
    z: np.ndarray
) -> np.ndarray:
    """
    Compute log P(Z_i = z | x_i) for all i.

    This corresponds to the likelihood term in Eq. (5.3) & Eq. (5.4).
    """

def posterior(
    model: NaiveBayesFingerprintModel,
    z: np.ndarray
) -> np.ndarray:
    """
    Compute posterior P(x_i | Z_i = z) over all i.

    Implements Eq. (5.3) with normalization over i.
    """

def map_localize(
    model: NaiveBayesFingerprintModel,
    z: np.ndarray
) -> np.ndarray:
    """
    ML/MAP estimate based on Eq. (5.4):

        i* = argmax_i P(Z_i = z | x_i) (with uniform priors),

    and returns x_hat = x_{i*}.
    """

def posterior_mean_localize(
    model: NaiveBayesFingerprintModel,
    z: np.ndarray
) -> np.ndarray:
    """
    Posterior-mean estimate of location:

        x_hat = sum_i P(x_i | Z_i = z) * x_i    (Eq. (5.5))
    """


Equation mapping:

posterior ‚Üî Eq. (5.3).

map_localize ‚Üî Eq. (5.4).

posterior_mean_localize ‚Üî Eq. (5.5).

Corresponding entries in equation_index.yml.

4.7.5 Advanced / model-based fingerprinting (optional)

For the ray-tracing / position-hypothesized method (Eqs. (5.7)‚Äì(5.11)), implement only lightweight helpers in core/fingerprinting/model_based.py:

gaussian_likelihood(z, z_pred, sigma) ‚Äì measurement likelihood reused by demos.

raytrace_likelihood(z, z_pred, sigma) ‚Äì convenience wrapper for ‚Äúray-traced‚Äù features.

The full position-hypothesized particle method (sampling states from a Gaussian prior, computing likelihoods, then weighted averaging as in Eq. (5.11)) is implemented as a chapter demo in ch5_fingerprinting (Section 7.4.5), not as a generic core API.

Docstrings for these helpers reference the likelihood concept used in Eqs. (5.8)‚Äì(5.10).

4.7.6 Simulation data requirements (for fingerprinting)

core/fingerprinting relies on at least one standardized dataset family in data/sim/:

wifi_fingerprint_grid/:

locations.*: (M, d) reference point coordinates.

fingerprints.*: (M, N) mean feature vectors f_i.

Optional fingerprints_samples/: raw RSS samples per RP for probabilistic model fitting.

query_trajectories/: sequences (x_true(t), z(t)) for evaluation.

Metadata: AP IDs, floor labels, building ID, etc.

These are used by:

Unit tests:

tests/test_fingerprinting_deterministic.py

tests/test_fingerprinting_probabilistic.py

Chapter 5 examples in ch5_fingerprinting (Section 7.4).

5. Simulation Datasets & Open Data
5.1 Principles

All primary examples must run only on data in data/sim/.

Datasets must be:

Small enough to clone and run quickly.

Reproducible (fixed seeds, recorded configs).

Clearly licensed (e.g. CC-BY-4.0) and documented in docs/data.md.

5.2 Dataset Families

Planned families under data/sim/:

rf_2d_floor/
2D or 2.5D floor map with known beacon/anchor positions (in ENU coordinates).

True agent trajectories:

Static points (for pure point positioning).

Moving paths (for time-series demos and filter comparisons).

Generated measurement files (or generation configs) for:

TOA / two-way TOA ranges d^a_i (Eqs. (4.1)‚Äì(4.3), (4.6)‚Äì(4.7)).

RSS values p^R_{a,i} with path-loss parameters (Eqs. (4.11)‚Äì(4.13)).

TDOA range differences d^a_{i,j} (Eqs. (4.27)‚Äì(4.33)).

AOA azimuth/elevation (Eqs. (4.63)‚Äì(4.67)).

Noise configuration file (YAML/JSON) specifying:

Timing noise std, oscillator jitter, RSS variance, angle noise.

NLOS bias templates for selected beacons (used in the Chapter 4 ‚ÄúRF challenges‚Äù example).

Coordinate frames:

All positions expressed in ENU with a documented origin and height reference.

wifi_fingerprint_grid/
Reference points on a grid, RSS vectors, test trajectories.

pdr_corridor_walk/
IMU time series, reference path, step labels, floor labels.

slam_lidar2d/
2D occupancy grid, range-bearing measurements, ground truth poses.

toy_ls_linear/
Simple linear system for least squares testing:

Files: H.npy, y.npy, x_true.npy, noise_config.json.

Used by: core/estimators/least_squares.py unit tests and ch3_estimators examples.

toy_kf_1d_cv/
1D constant velocity system:

Files: x_true.npy, z.npy, F.npy, H.npy, Q.npy, R.npy, dt.

Used to validate KalmanFilter implementation and tuning.

toy_nonlinear_1d/
Nonlinear state/measurement example:

State trajectory file, nonlinear measurement config, noise statistics.

Used by: EKF, UKF, PF, and FGO examples to illustrate behavior under non-Gaussian/nonlinear conditions.

For each dataset:

File formats: CSV / NPZ / HDF5.

Coordinate frames: clearly defined, link to core/coords.

Ground truth semantics.

5.3 Optional Real Data

data/real/ may contain small demo logs (not full research datasets) to show real-world quirks.

Not a core dependency for running per-chapter examples.

6. Equation‚Äìto‚ÄìCode Mapping Design

This section defines how equation mapping is implemented, enforced, and integrated with core/ and chapter modules.

6.1 Canonical Equation ID Format

Equations are referenced using a canonical string:

Eq. (C.NN) for Chapter C, Equation NN.

If the book uses section-based numbering, adapt to Eq. (C.SS).

Examples:

Chapter 2, equation 5 ‚Üí Eq. (2.5)

Chapter 3, equation 12 ‚Üí Eq. (3.12)

Rules:

This exact string must appear in:

Docstrings.

Comments (for line-level mapping).

Notebooks (markdown cells).

docs/equation_index.yml.

That way, a simple repo search for "Eq. (3.12)" finds all relevant code/tests.

6.2 Code Conventions (Docstrings & Comments)

Requirement:

Every function/class that directly implements a book equation must mention it in its docstring.

Example: LS

def linear_least_squares(A: np.ndarray, b: np.ndarray) -> np.ndarray:
    """
    Solve the linear least squares problem x* = argmin ||Ax - b||_2.

    Implements Eq. (3.12) in Chapter 3 of the book:
        x* = (A^T A)^{-1} A^T b
    """
    ...


Example: EKF predict

def predict(self, u: np.ndarray) -> None:
    """
    Extended Kalman filter prediction step.

    Implements Eqs. (3.25)‚Äì(3.27) in Chapter 3:
        - State propagation: Eq. (3.25)
        - Jacobian: Eq. (3.26)
        - Covariance propagation: Eq. (3.27)
    """
    ...


Line-level comments

If a specific line encodes an equation:

# Eq. (3.27): P_{k|k-1} = F_k P_{k-1|k-1} F_k^T + Q_k
P_pred = F @ P @ F.T + Q


Design rule:

Whole function = one equation (or block) ‚Üí docstring reference.

Single expression or key step = equation ‚Üí inline comment with the exact Eq. (C.NN) reference.

6.3 Central Equation Index File

Create docs/equation_index.yml (or .json).

Purpose:

From the book side, you can look up "Eq. (3.12)" and see:

Which modules/objects implement it.

Which tests/notebooks exercise it.

YAML structure (example):

- eq: "Eq. (2.3)"
  chapter: 2
  description: "ECEF to ENU coordinate transformation"
  files:
    - path: "core/coords/frames.py"
      object: "ecef_to_enu"
    - path: "ch2_coords/examples/coord_demo.py"
      object: "demo_ecef_to_enu"
  tests:
    - "tests/test_coords.py::test_ecef_enu_roundtrip"

- eq: "Eq. (3.12)"
  chapter: 3
  description: "Linear least squares closed form"
  files:
    - path: "core/estimators/least_squares.py"
      object: "linear_least_squares"
  notebooks:
    - "notebooks/ch3_estimators/ls_vs_ekf.ipynb"


Design choices:

One entry per implemented equation.

Keys:

eq ‚Äì canonical ID ("Eq. (3.12)").

chapter

description

files ‚Äì list of {path, object}.

Optional: tests, notebooks, notes.

6.4 Notebooks & Docs Conventions

Notebooks:

At the top of each chapter notebook, add an ‚ÄúEquations used‚Äù list, e.g.:

Eq. (3.12): Linear least squares solution.

Eqs. (3.25)‚Äì(3.27): EKF prediction equations.

And reference equations in text:

We now implement the linear least squares estimator from Eq. (3.12).

Docs:

In docs/ch3_estimators.md:

## Equation map

- Eq. (3.12): `core/estimators/least_squares.py::linear_least_squares`
- Eqs. (3.25)‚Äì(3.27): `core/estimators/kalman.py::ExtendedKalmanFilter.predict`


This gives users three navigation routes:

Search "Eq. (3.12)" in the repo.

Check docs/equation_index.yml.

Read chapter docs listing mappings.

6.5 Tooling: Equation Index Checker Script

Add tools/check_equation_index.py:

Responsibilities:

Parse docs/equation_index.yml.

For every {path, object} entry:

Verify the module and object exist.

Verify the docstring or comments contain the mapped "Eq. (C.NN)".

Sketch (conceptually):

Use importlib to load modules.

Inspect obj.__doc__.

Fail CI if any mismatch.

Integrate in CI:

Run pytest.

Run python tools/check_equation_index.py.

6.6 Integration into Epics / Phases

For each epic, ‚Äúdefinition of done‚Äù includes:

Code & tests written.

Example notebook added.

Equation mapping completed:

Docstring references added.

equation_index.yml updated.

Notebook/docs list relevant equations.

Concretely:

Epic 1 ‚Äì Coordinates (Ch.2)
All transforms tagged with Eq. (2.x) where applicable.

Epic 2 ‚Äì Estimators (Ch.3)
LS, KF, EKF, UKF, PF, FGO all mapped to Ch.3 equations.

Epic 3 ‚Äì RF positioning (Ch.4)
TOA/TDOA/AOA/RSS and DOP models mapped.

Subsequent epics (fingerprinting, PDR, SLAM, fusion) follow the same pattern.

7. Per-Chapter Example Modules (Unique Tasks)

For each chX_... folder, list:

Example scripts / notebooks.

Which core/ functions they exercise.

Which equations they highlight.

Standard visualization outputs (all chapters)

For each chX_... module, at least one example must:

call core/eval metrics to compute errors / statistics, and

call core/eval/plots.py to generate:

a trajectory or map view, and

at least one error/time or error/CDF plot.

All examples should save figures via save_figure(...) into:

chX_.../figs/ (scripts), or

notebooks/figs/chX_.../ (notebooks),

so that:

readers can quickly compare different algorithms or datasets by opening the SVG/PDF files, and

instructors can directly reuse the vector figures in slides and course materials without manual re-plotting.

7.1 ch2_coords/

Examples

demo_frames.py
Build body/map/ENU/NED frames and print transforms.

Simple plotting script to reproduce or echo Ch.2 figures.

Dependencies

core.coords, core.sim, core.eval.

7.2 ch3_estimators/

Examples

ls_vs_robust_ls.py
Outlier demo: LS vs Huber vs Cauchy.

kf_vs_ekf_vs_ukf_vs_pf_vs_fgo.ipynb
1D/2D toy system comparing estimator families.

Unique tasks

Compare convergence, RMSE, computation time.

Show qualitatively how different estimators behave under same conditions.

7.3 ch4_rf_point_positioning/ ‚Äì Point Positioning by Radio Signals (Chapter 4)
7.3.1 Purpose

This module provides end-to-end simulation examples for Chapter 4: Point Positioning by Radio Signals.

Main goals:

Demonstrate TOA, two-way TOA/RTT, RSS-based ranging, TDOA, and AOA positioning on a common simulated floorplan (rf_2d_floor dataset).

Compare:

Iterative WLS / I-WLS vs closed-form algorithms (Fang, Chan).

Different measurement types (TOA vs TDOA vs AOA vs RSS) under the same geometry and noise levels.

Make the link between Chapter 4 equations and actual numerical behavior explicit via equation-level traceability.

This is a Chapter-specific wiring layer: it uses core/rf, core/estimators, core/coords, core/sim, and core/eval, plus data/sim/rf_2d_floor/.

7.3.2 Dependencies

Core modules

core/rf ‚Äì TOA/TDOA/AOA/RSS measurement models, DOP utilities.

core/estimators ‚Äì LS / WLS / robust LS, Gauss‚ÄìNewton, LM, FGO.

core/coords ‚Äì ENU frame and beacon/agent coordinates.

core/sim ‚Äì floorplan, anchors, trajectory generation, noise injection.

core/eval ‚Äì error metrics, CDFs, DOP and geometry plots.

Data

data/sim/rf_2d_floor/ (Section 5.2).

Notebooks

notebooks/ch4_rf_point_positioning/*.ipynb.

7.3.3 Example scenarios & scripts

Scenario A ‚Äì Direct ranging: TOA / two-way TOA / RSS (Section 4.2)

Key equations

TOA models:
Basic TOA range and variants with clock offsets (Eqs. (4.1)‚Äì(4.3)).

Two-way TOA (RTT):
RTT distance with and without processing delay (Eqs. (4.6)‚Äì(4.7)).

RSS path-loss:
Path-loss inversion and fading/noise models (Eqs. (4.11)‚Äì(4.13)).

Nonlinear TOA LS/I-WLS:
Measurement vector, state, nonlinear range, linearization and iterative WLS update (Eqs. (4.14)‚Äì(4.23)).

Joint position + clock bias:
Extended state and modified TOA model (Eqs. (4.24)‚Äì(4.26)).

Planned examples

ch4_rf_point_positioning/direct_ranging_tutorial.ipynb

Generate TOA / two-way TOA / RSS measurements from rf_2d_floor using core/rf.

Implement:

Plain LS on ranges (linearized Eq. (4.16)).

I-WLS using Eqs. (4.14)‚Äì(4.23).

Compare TOA vs RTT vs RSS positioning under different noise levels.

Show how initial guess and weighting matrix affect convergence and accuracy.

ch4_rf_point_positioning/direct_ranging_clock_offset.py

Include clock bias in the state:

State vector and distance model from Eqs. (4.24)‚Äì(4.26).

Demonstrate joint estimation of position and clock bias.

Equation mapping

Docstrings explicitly reference:

‚ÄúTOA model in Eqs. (4.1)‚Äì(4.3), (4.6)‚Äì(4.7)‚Äù

‚ÄúNonlinear TOA I-WLS algorithm from Eqs. (4.14)‚Äì(4.23)‚Äù

‚ÄúJoint position + clock bias formulation from Eqs. (4.24)‚Äì(4.26)‚Äù

equation_index.yml maps these equations to:

TOA/RSS functions in core/rf.

Example helpers in ch4_rf_point_positioning.

Scenario B ‚Äì TDOA positioning: LS / WLS vs Fang & Chan (Section 4.3)

Key equations

TDOA definition and range differences:
Uplink/downlink TDOA and range differences (Eqs. (4.27)‚Äì(4.33)).

TDOA LS/WLS:
Linearized TDOA system, LS and WLS solutions, weighting matrix (Eqs. (4.34)‚Äì(4.42)).

Fang & Chan closed-form hyperbolic algorithms:
Hyperbolic relationships and algebraic LS forms (Eqs. (4.43)‚Äì(4.48), plus refinement in Eq. (4.58)).

Planned examples

ch4_rf_point_positioning/tdoa_ls_vs_iwls.ipynb

Use TDOA measurements from rf_2d_floor.

Implement:

Basic TDOA LS.

WLS with correct covariance weighting.

Compare with TOA-based positioning (Scenario A).

ch4_rf_point_positioning/tdoa_fang_chan.py

Implement Fang‚Äôs closed-form TDOA algorithm.

Implement Chan‚Äôs two-step algorithm:

Step 1: LS.

Step 2: WLS refinement with covariance.

Compare Fang, Chan, and LS/I-WLS under:

Varying noise levels.

Good vs. poor anchor geometry.

Equation mapping

Docstrings reference:

‚ÄúTDOA LS/WLS from Eqs. (4.34)‚Äì(4.42).‚Äù

‚ÄúFang‚Äôs algorithm from Eqs. (4.43)‚Äì(4.48).‚Äù

‚ÄúChan‚Äôs two-step refinement including Eq. (4.58).‚Äù

equation_index.yml maps these equations to:

TDOA helpers in core/rf.

Scenario scripts in ch4_rf_point_positioning.

Scenario C ‚Äì AOA positioning: LS/I-WLS, OVE, 3D PLE (Section 4.4)

Key equations

AOA geometry:
Vertical and azimuth angle relationships (Eqs. (4.63)‚Äì(4.64)).

AOA measurement vectors and stacking:
Single-beacon and multi-beacon measurement vectors (Eqs. (4.65)‚Äì(4.66)).

State vector consistency:
State definition reused from range-based positioning (Eq. (4.35)).

Linearization and LS/I-WLS:
Linearized form and Jacobians of the AOA model (Eqs. (4.63)‚Äì(4.67)).

Planned examples

ch4_rf_point_positioning/aoa_ls_iwls.ipynb

Generate azimuth/elevation AOA measurements for anchors in rf_2d_floor.

Implement:

LS AOA solver based on linearized Eqs. (4.63)‚Äì(4.67).

I-WLS refinement using multiple iterations.

ch4_rf_point_positioning/aoa_ove_3dple.py

Implement OVE and 3D PLE methods as described in Section 4.4.

Compare OVE and 3D PLE vs LS/I-WLS under:

Different noise levels.

Different beacon height distributions and geometries.

Equation mapping

Docstrings indicate:

‚ÄúAOA LS/I-WLS based on Eqs. (4.63)‚Äì(4.67).‚Äù

‚ÄúOVE / 3D PLE built on the same AOA geometry (Eqs. (4.63)‚Äì(4.67)).‚Äù

equation_index.yml links these equations to:

AOA models in core/rf.

AOA demo scripts in ch4_rf_point_positioning.

Scenario D ‚Äì RF challenges & limitations (Section 4.5)

Focus

Illustrate limitations and realistic imperfections discussed in Section 4.5:

Thermal noise and oscillator instability.

Multipath and NLOS biases.

Poor beacon geometry (high DOP).

Sensitivity to initialization in nonlinear WLS.

Planned example

ch4_rf_point_positioning/rf_challenges.ipynb

Baseline scenario:

Well-conditioned TOA/TDOA/AOA geometry and low noise.

Progressive stress tests:

Add oscillator noise:

Show how timing noise propagates into range and position errors.

Tie back to assumptions in TOA/TDOA models (Eqs. (4.1)‚Äì(4.3), (4.27)‚Äì(4.33)).

Add NLOS:

Inject biases on selected anchors using rf_2d_floor noise config.

Compare LS vs I-WLS robustness.

Change geometry:

Cluster anchors or limit them to one side; visualize DOP using core/eval.

Relate GDOP/HDOP/PDOP to position error statistics.

Bad initialization:

Show TOA I-WLS divergence or convergence to wrong local minima for poor initial guesses.

Equation mapping

Markdown cells explicitly mention which ideal assumptions from Chapter 4‚Äôs equations are being violated in each experiment.

These are behavior-focused demos rather than new implementations, but they still reference:

TOA/TDOA/AOA model equations.

DOP formulas (from core/rf and Chapter 4).

7.3.4 Tests

Scenario-level regression tests to complement core/ unit tests:

tests/ch4/test_direct_ranging_accuracy.py
For a fixed rf_2d_floor config and random seed:
Check TOA I-WLS RMSE is below a threshold (e.g. < Œµ m).

tests/ch4/test_tdoa_chan_fang_consistency.py
For a simple configuration:
Confirm Fang and Chan solutions are close to LS/I-WLS when noise is small.

tests/ch4/test_aoa_methods.py
Verify LS/I-WLS/OVE/3D PLE solutions converge within tolerance in a nominal AOA scenario.

These tests ensure the wiring between datasets, core/ models, and Chapter-4 examples remains intact.

7.4 ch5_fingerprinting/
7.4.1 Goals

Demonstrate deterministic vs probabilistic fingerprinting as introduced in Chapter 5.

Show pattern-recognition formulations (classification/regression) using the same synthetic fingerprints.

Optionally demonstrate a model-based + particle/hypothesis example using ray-tracing-like simulation and the position-hypothesized method.

Every example must:

Use core/fingerprinting for algorithms.

Use core/eval for error metrics and CDF/trajectory plots.

Call save_figure(...) to output vector figures into ch5_fingerprinting/figs/.

7.4.2 Example 1 ‚Äì Deterministic NN / k-NN (Eqs. (5.1)‚Äì(5.2))

Files:

ch5_fingerprinting/demo_deterministic_nn_knn.py

notebooks/ch5_fingerprinting/demo_deterministic_nn_knn.ipynb

Core functions used:

core.fingerprinting.deterministic.nn_localize (Eq. (5.1)).

core.fingerprinting.deterministic.knn_localize (Eq. (5.2)).

core.eval.compute_position_errors, core.eval.plot_error_cdf, core.eval.plot_trajectory_2d.

Equations to highlight:

Eq. (5.1): nearest-neighbor decision rule.

Eq. (5.2): weighted k-NN interpolation.

Notebook structure:

Markdown header ‚ÄúEquations used in this notebook‚Äù:

Eq. (5.1): Nearest-neighbor fingerprinting rule.

Eq. (5.2): Weighted k-NN interpolated position estimate.

Code cells:

Load wifi_fingerprint_grid/.

Simulate query fingerprints along a test trajectory (add noise).

Run NN and k-NN for different k (e.g. 1, 3, 5, 10).

Compute RMSE and error CDFs using core.eval.

Plots:

ch5_fingerprinting/figs/ch5_nn_vs_knn_cdf.svg.

ch5_fingerprinting/figs/ch5_nn_vs_knn_traj.svg.

Equation mapping:

Notebook header explicitly lists Eqs. (5.1)‚Äì(5.2).

docs/ch5_fingerprinting.md ‚ÄúEquation map‚Äù section will include:

Eq. (5.1): core/fingerprinting/deterministic.py::nn_localize.

Eq. (5.2): core/fingerprinting/deterministic.py::knn_localize.

7.4.3 Example 2 ‚Äì Probabilistic (Bayesian) fingerprinting (Eqs. (5.3)‚Äì(5.5))

Files:

ch5_fingerprinting/demo_probabilistic_bayes.py

notebooks/ch5_fingerprinting/demo_probabilistic_bayes.ipynb

Core functions used:

fit_gaussian_naive_bayes, posterior, map_localize, posterior_mean_localize from core.fingerprinting.probabilistic.

core.eval.compute_position_errors, core.eval.plot_error_cdf.

Equations to highlight:

Eq. (5.3): posterior 
ùëÉ
(
ùë•
ùëñ
‚à£
ùëç
ùëñ
=
ùëß
)
P(x
i
	‚Äã

‚à£Z
i
	‚Äã

=z).

Eq. (5.4): ML/MAP estimate.

Eq. (5.5): posterior-mean estimate.

Notebook structure:

Markdown header ‚ÄúEquations used in this notebook‚Äù:

Eq. (5.3): Bayesian posterior over locations.

Eq. (5.4): ML/MAP fingerprint-based location estimate.

Eq. (5.5): Posterior-mean location.

Code:

Load wifi_fingerprint_grid/ with multiple samples per RP.

Fit Naive Bayes model (means/variances per RP).

Compare:

Deterministic NN (from Example 1).

MAP estimator (Eq. 5.4).

Posterior mean estimator (Eq. 5.5).

Plots:

ch5_fingerprinting/figs/ch5_det_vs_prob_cdf.svg.

Optional: posterior heatmap for a single query point.

Equation mapping:

Notebook references Eqs. (5.3)‚Äì(5.5) in text.

equation_index.yml entries point to posterior, map_localize, posterior_mean_localize.

7.4.4 Example 3 ‚Äì Pattern recognition (classification & regression) ‚Äì Section 5.2

File:

notebooks/ch5_fingerprinting/demo_pattern_recognition.ipynb

Core functions used:

New simple wrappers in core/fingerprinting/pattern_recognition.py, e.g.:

LinearRegressionLocalizer (xÃÇ = W f + b).

Optional: simple MLP classifier/regressor (thin wrapper around scikit-learn or PyTorch if allowed).

Concepts to highlight:

Classification view: treating each reference point / area as a class.

Regression view: mapping features directly to continuous coordinates.

Notebook structure:

Markdown references to Chapter 5, Section 5.2.1 (classification) and 5.2.2 (regression).

Code:

Build a classifier across regions/cells of the grid.

Build a regression model for continuous x,y from features.

Compare performance to NN/k-NN and Bayesian methods.

Equation mapping:

If the book defines explicit equations (e.g. linear regression form), docstrings in LinearRegressionLocalizer reference the Eq. (5.x); otherwise, they reference the section numbers (5.2.1 / 5.2.2).

7.4.5 Example 4 ‚Äì Model-based + PF demo (Eqs. (5.7)‚Äì(5.11), optional/advanced)

File:

notebooks/ch5_fingerprinting/demo_raytracing_pf.ipynb

Core modules used:

core.sim ‚Äì to generate a simple 2D map and simulate ‚Äúray-tracing-like‚Äù features.

core.fingerprinting.model_based ‚Äì likelihood helpers.

Optionally core.estimators.ParticleFilter as a base implementation.

Equations to highlight:

Eq. (5.7): Gaussian prior over hypothesized states around an initial guess.

Eqs. (5.8)‚Äì(5.10): Gaussian likelihoods of simulated measurements.

Eq. (5.11): weighted average over hypotheses to produce an estimate.

Notebook structure:

Header ‚ÄúEquations used in this notebook‚Äù listing Eqs. (5.7)‚Äì(5.11).

Code:

Define a small 2D environment and ‚Äúray-tracing-like‚Äù simulator (simplified).

Sample particles around a prior mean (Eq. 5.7).

Compute likelihoods with gaussian_likelihood / raytrace_likelihood (Eqs. 5.8‚Äì5.10).

Compute weighted average of particles as position estimate (Eq. 5.11).

Compare performance vs a simpler deterministic method.

Plots:

Particle cloud colored by likelihood.

Position error statistics compared to deterministic fingerprinting.

Equation mapping:

Eqs. (5.7)‚Äì(5.11) are referenced in notebook markdown and in equation_index.yml as notebook-based implementations (not core functions).

7.4.6 Dependencies

core.fingerprinting (deterministic, probabilistic, pattern-recognition wrappers).

core.rf and core.sim (to generate synthetic fingerprints for wifi_fingerprint_grid/).

core.eval for metrics and visualization.

data/sim/wifi_fingerprint_grid/.

7.5 ch6_dead_reckoning/

(Keep this short summary at the top for readability)

Examples (summary)

Foot-mounted PDR with ZUPT:
Walk along corridor, accumulate drift, correct with constraints.

Vehicle odom + IMU:
Simple car-like motion on a map.

7.5.1 Purpose

This module provides end-to-end simulation examples for Chapter 6:

Strapdown IMU propagation (shows drift).

Wheel odometry dead reckoning (shows drift + sensitivity).

Integrated IMU + wheel EKF (reduces drift).

Foot-mounted ZUPT INS (constraint-based drift correction).

Step-and-heading PDR baseline (simple but fragile).

Environmental sensors (magnetometer heading and barometer altitude).

All examples must:

Use core/sensors for models and algorithms.

Use core/estimators for KF/EKF update machinery (single source of truth).

Use core/eval for metrics and vector plot export (save_figure).

7.5.2 Dependencies

Core modules

core/sensors ‚Äì Chapter 6 models.

core/estimators ‚Äì KF/EKF used for constraint and fusion updates.

core/coords ‚Äì quaternion/rotmat conversions.

core/sim ‚Äì trajectory generation + sensor noise injection.

core/eval ‚Äì metrics and standardized plots.

Data

data/sim/ch6_* (see Section 5.2).

Notebooks

notebooks/ch6_dead_reckoning/*.ipynb.

7.5.3 Example scenarios & notebooks/scripts

Scenario 6A ‚Äì Strapdown IMU propagation (drift demo)

Key equations (Chapter 6)

Quaternion kinematics and discrete update: Eqs. (6.2)‚Äì(6.4), Œ© matrix Eq. (6.3).

Gyro model/correction: Eqs. (6.5)‚Äì(6.6).

Velocity and gravity: Eqs. (6.7)‚Äì(6.8).

Accelerometer model and position update: Eqs. (6.9)‚Äì(6.10).

Notebook

notebooks/ch6_dead_reckoning/strapdown_imu_drift.ipynb

Must show

Perfect IMU vs biased IMU drift.

Trajectory plot (truth vs estimate) + error vs time.

Save vector outputs into notebooks/figs/ch6_dead_reckoning/.

Scenario 6B ‚Äì Wheel odometry dead reckoning (vehicle)

Key equations

Lever arm compensation and skew matrix: Eqs. (6.11)‚Äì(6.12).

Velocity transform and position update: Eqs. (6.14)‚Äì(6.15).

Notebook

notebooks/ch6_dead_reckoning/wheel_odometry_dr.ipynb

Must show

DR drift under noise.

Failure mode under injected slip.

Scenario 6C ‚Äì Integrated IMU + wheel EKF (vehicle)

Key equations

State definition: Eq. (6.16).

Process propagation and covariance: Eqs. (6.17)‚Äì(6.32).

Wheel measurement model and Jacobian: Eqs. (6.33)‚Äì(6.38).

EKF update block: Eqs. (6.39)‚Äì(6.43).

Notebook

notebooks/ch6_dead_reckoning/imu_wheel_ekf.ipynb

Must show

Compare:

IMU-only strapdown

wheel-only DR

integrated EKF

Report RMSE and drift summary.

Implementation rule

Do not duplicate EKF update math here; call core/estimators EKF update.

Scenario 6D ‚Äì Foot-mounted ZUPT INS (drift correction)

Key equations

ZUPT detector: Eq. (6.44)

ZUPT pseudo-measurement: Eq. (6.45)

Optional: ZARU pseudo-measurement: Eq. (6.60)

Notebook

notebooks/ch6_dead_reckoning/foot_zupt_ins.ipynb

Must show

IMU drift vs ZUPT-corrected drift.

Plot detector firing timeline.

Scenario 6E ‚Äì Step-and-heading PDR baseline

Key equations

Acceleration magnitude and gravity removal: Eqs. (6.46)‚Äì(6.47).

Step frequency, step length, step update: Eqs. (6.48)‚Äì(6.50).

Notebook

notebooks/ch6_dead_reckoning/pdr_step_heading.ipynb

Must show

Sensitivity to user height h and personal factor c.

Compare heading sources:

gyro yaw integration (drifts)

magnetometer heading (can jump under disturbance)

Scenario 6F ‚Äì Magnetometer + barometer demos

Key equations

Magnetometer heading: Eqs. (6.51)‚Äì(6.53).

Barometer altitude: Eq. (6.54).

Generic state/measurement form: Eq. (6.55) (for smoothing helper).

Notebook

notebooks/ch6_dead_reckoning/env_heading_altitude.ipynb

Must show

Mag disturbance intervals causing heading jumps.

Barometer altitude trend and offset handling.

Optional smoothing using core/estimators.

7.5.4 Tests (Chapter 6)

Add tests under tests/ch6/:

tests/ch6/test_quaternion_propagation.py
Validate quat_integrate normalization and sanity for simple rotation cases.
(Eqs. (6.2)‚Äì(6.4))

tests/ch6/test_strapdown_stationary.py
Stationary IMU should maintain near-zero velocity and stable position (within tolerance).
(Eqs. (6.7)‚Äì(6.10))

tests/ch6/test_wheel_odometry_update.py
Known straight-line motion: wheel DR matches truth within tolerance.
(Eqs. (6.11)‚Äì(6.15))

tests/ch6/test_imu_wheel_ekf_smoke.py
Integrated EKF RMSE < min(IMU-only, wheel-only) for a fixed seed and config.
(Eqs. (6.16)‚Äì(6.43))

tests/ch6/test_zupt_detector.py
Synthetic stance intervals trigger Eq. (6.44) detector behavior.

tests/ch6/test_pdr_step_length.py
Validate step length computation and step update correctness.
(Eqs. (6.48)‚Äì(6.50))

tests/ch6/test_mag_baro_models.py
Validate magnetometer heading and barometer altitude transforms.
(Eqs. (6.51)‚Äì(6.54))

7.5.5 Standard visualization outputs (Chapter 6)

Each notebook/script must generate at least:

Trajectory plot (truth vs estimate) ‚Üí SVG/PDF

Error vs time plot (position error, heading error, altitude error) ‚Üí SVG/PDF

(Optional) CDF plot for position error if comparing multiple methods

Naming examples

ch6_strapdown_drift_traj.svg
ch6_imu_wheel_ekf_error_time.pdf
ch6_zupt_detector_timeline.svg
ch6_pdr_heading_comparison.svg

7.5.6 Equation mapping entries to add (Chapter 6)

Add entries in docs/equation_index.yml mapping Chapter-6 equations to code objects, for example:

Eqs. (6.2)‚Äì(6.4) ‚Üí core/sensors/strapdown.py::quat_integrate

Eq. (6.3) ‚Üí core/sensors/strapdown.py::omega_matrix

Eqs. (6.5)‚Äì(6.6) ‚Üí core/sensors/imu_models.py::correct_gyro

Eq. (6.7) ‚Üí core/sensors/strapdown.py::vel_update

Eq. (6.8) ‚Üí core/sensors/strapdown.py::gravity_vector

Eq. (6.9) ‚Üí core/sensors/imu_models.py::correct_accel

Eq. (6.10) ‚Üí core/sensors/strapdown.py::pos_update

Eqs. (6.11)‚Äì(6.15) ‚Üí core/sensors/wheel_odometry.py::{skew, wheel_speed_to_attitude_velocity, attitude_to_map_velocity, odom_pos_update}

Eqs. (6.16)‚Äì(6.32) ‚Üí core/sensors/ins_ekf_models.py::InsWheelProcessModel

Eqs. (6.33)‚Äì(6.38) ‚Üí core/sensors/ins_ekf_models.py::WheelSpeedMeasurementModel

Eqs. (6.39)‚Äì(6.43) ‚Üí core/estimators/kalman.py::ExtendedKalmanFilter.update
(extend docstring to mention Chapter 6 EKF update block)

Eq. (6.44) ‚Üí core/sensors/constraints.py::detect_zupt

Eq. (6.45) ‚Üí core/sensors/constraints.py::ZuptMeasurementModel

Eqs. (6.46)‚Äì(6.47) ‚Üí core/sensors/pdr.py::{total_accel_magnitude, remove_gravity_from_magnitude}

Eqs. (6.48)‚Äì(6.50) ‚Üí core/sensors/pdr.py::{step_frequency, step_length, pdr_step_update}

Eqs. (6.51)‚Äì(6.53) ‚Üí core/sensors/environment.py::mag_heading

Eq. (6.54) ‚Üí core/sensors/environment.py::pressure_to_altitude

Eq. (6.55) ‚Üí core/sensors/environment.py::(smoothing helper, if implemented)

Eqs. (6.56)‚Äì(6.58) ‚Üí core/sensors/calibration.py::allan_variance

Eq. (6.59) ‚Üí core/sensors/calibration.py::apply_imu_scale_misalignment

Eq. (6.60) ‚Üí core/sensors/constraints.py::ZaruMeasurementModel

Eq. (6.61) ‚Üí core/sensors/constraints.py::NhcMeasurementModel

7.6 ch7_slam/

Examples

Minimal 2D LiDAR / range-bearing SLAM:
Use FGO with pose + landmark factors.

Loop closure toy example.

7.7 ch8_sensor_fusion/

Examples

Loosely vs tightly coupled fusion examples:
GNSS+IMU style but adapted to indoor sensors.

Observability demo:
Show drift/unobservability vs properly fused sensors.

Calibration:
Simple intrinsic/extrinsic calibration toy.

For each chapter section, the design doc should separate:

Core functions reused from core/.

Chapter-specific ‚Äúunique tasks‚Äù and plots.

8. Non-Functional Requirements
8.1 Language & Tooling

Python 3.x.

NumPy, SciPy, matplotlib, optional JAX/PyTorch for ML examples (kept light).

Packaging via pyproject.toml / poetry or similar.

8.2 Quality

Unit tests for all core functions (tests/).

pytest-based CI.

Equation index checker included in CI.

8.3 Performance

All examples should run on a typical laptop in minutes, not hours.

Datasets and notebooks: no GPU dependency required.

8.4 Documentation

docs/:

Per-chapter docs (overview, how to run examples).

docs/equation_index.yml and usage instructions.

README.md:

Explain structure, target audience, and how to map book ‚Üî repo.

9. Implementation Roadmap

Use epics as a roadmap for you + contributing engineers.

9.1 Epic 0 ‚Äì Repo & Infrastructure

Initialize repo structure.

Set up:

core/, chX_.../, data/, notebooks/, docs/, tools/.

CI with pytest + equation checker.

9.2 Epic 1 ‚Äì Coordinates (Ch.2)

Implement core/coords.

Add tests for:

LLH‚ÜîECEF‚ÜîENU round-trip.

ENU‚ÜîNED conversions.

Implement ch2_coords examples.

Add Ch.2 equations to equation_index.yml.

9.3 Epic 2 ‚Äì Estimators (Ch.3)

Implement LS/WLS + robust LS in core/estimators.

Implement KF/EKF/UKF/PF skeletons.

Add simple FGO wrapper.

Unit tests (simple linear systems).

ch3_estimators example notebook.

Update equation_index.yml for Ch.3.

9.4 Epic 3 ‚Äì RF Positioning (Ch.4)

Implement measurement models and DOP in core/rf.

Build RF simulation tools in core/sim.

ch4_rf_point_positioning examples:

TOA, TDOA (Chan/Fang), AOA demos, and RF challenges notebook.

Add Ch.4 equations to equation_index.yml.

9.5 Epic 4 ‚Äì Sensors & Dead Reckoning (Ch.6)

Implement core/sensors detailed in Section 4.4.

Add Chapter 6 dataset families under data/sim/ (Section 5.2).

Implement ch6_dead_reckoning notebooks (Section 7.5).

Add tests under tests/ch6/.

Update equation_index.yml for Chapter 6 and ensure equation checker passes.

9.6 Later Epics ‚Äì Fingerprinting, SLAM, Fusion

Similar pattern:

Spec ‚Üí core implementation ‚Üí tests ‚Üí examples ‚Üí docs ‚Üí equation mapping.

10. Working Effectively: SW vs Navigation Engineers

Throughout the design doc, separate:

Algorithm / modeling decisions (navigation engineer):

Which equation(s) in the book to implement.

What approximations and parameters to use.

Implementation details (software engineer):

File layout, function signatures, performance, tests, CI.

The equation mapping system bridges the two:

Navigation engineers can check correctness by tracing Eq. ‚Üí code.

Software engineers can preserve traceability by following docstring + index conventions and the equation checker.